<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Chess</title>
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
  <style>
    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent-blue: #3b82f6;
      --accent-green: #22c55e;
      --accent-red: #ef4444;
      --accent-yellow: #eab308;
      --border-color: rgba(255,255,255,0.1);
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      min-height: 100vh;
      color: var(--text-primary);
    }

    .app {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
    }

    .header h1 {
      font-size: 1.25rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header-status {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .connection-status {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .connection-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-red);
    }

    .connection-dot.connected {
      background: var(--accent-green);
    }

    /* Setup Screen */
    .setup-screen {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .setup-card {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 32px;
      max-width: 480px;
      width: 100%;
      border: 1px solid var(--border-color);
    }

    .setup-card h2 {
      text-align: center;
      margin-bottom: 24px;
      font-size: 1.5rem;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .form-group select {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 1rem;
      cursor: pointer;
    }

    .color-picker {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .color-btn {
      padding: 16px;
      border-radius: 12px;
      border: 2px solid transparent;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .color-btn.white {
      background: #f8fafc;
      color: #1e293b;
    }

    .color-btn.black {
      background: #1e293b;
      color: #f8fafc;
      border-color: var(--border-color);
    }

    .color-btn:hover { transform: scale(1.02); }
    .color-btn.selected { border-color: var(--accent-blue); box-shadow: 0 0 20px rgba(59, 130, 246, 0.3); }

    .color-btn .piece {
      font-size: 2rem;
    }

    .start-btn {
      width: 100%;
      padding: 14px;
      border-radius: 10px;
      border: none;
      background: var(--accent-blue);
      color: white;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 8px;
      transition: all 0.2s;
    }

    .start-btn:hover { background: #2563eb; }
    .start-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .error-msg {
      background: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 16px;
      font-size: 0.875rem;
      text-align: center;
    }

    /* Game Screen */
    .game-screen {
      flex: 1;
      display: none;
      grid-template-columns: 1fr 380px;
      gap: 0;
      height: calc(100vh - 60px); /* Fixed height minus header */
      overflow: hidden;
    }

    .game-screen.active {
      display: grid;
    }

    @media (max-width: 900px) {
      .game-screen { grid-template-columns: 1fr; height: auto; }
      .chat-panel { border-left: none; border-top: 1px solid var(--border-color); max-height: 50vh; }
    }

    /* Board Panel */
    .board-panel {
      display: flex;
      flex-direction: column;
      padding: 20px;
      background: var(--bg-primary);
      overflow: hidden;
    }

    .game-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .turn-badge {
      padding: 6px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .turn-badge.white { background: #f8fafc; color: #1e293b; }
    .turn-badge.black { background: #1e293b; color: #f8fafc; border: 1px solid var(--border-color); }

    .status-text {
      font-size: 0.875rem;
      color: var(--text-secondary);
    }

    .status-text.thinking { color: var(--accent-yellow); }
    .status-text.check { color: var(--accent-red); font-weight: 600; }
    .status-text.game-over { color: var(--accent-green); font-weight: 600; }

    .board-wrapper {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #board, #training-board, #review-board {
      width: 100%;
      max-width: 520px;
    }

    .board-controls {
      display: flex;
      gap: 8px;
      margin-top: 16px;
      justify-content: center;
    }

    .board-controls button {
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-secondary);
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .board-controls button:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* Chat Panel */
    .chat-panel {
      display: flex;
      flex-direction: column;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-color);
      height: 100%;
      max-height: calc(100vh - 60px);
      overflow: hidden;
    }

    .chat-header {
      flex-shrink: 0;
      padding: 12px 16px;
      border-bottom: 1px solid var(--border-color);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .chat-header h3 {
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-secondary);
    }

    .voice-controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .voice-controls button {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: transparent;
      color: var(--text-muted);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .voice-controls button:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .voice-controls button.active {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    .voice-controls button.muted {
      background: var(--accent-red);
      border-color: var(--accent-red);
      color: white;
    }

    .voice-controls .icon-btn {
      padding: 6px 8px;
      font-size: 1.1rem;
    }

    /* Selected square highlight for click-to-move */
    .highlight-selected {
      box-shadow: inset 0 0 0 4px var(--accent-blue) !important;
    }

    .highlight-legal {
      background: radial-gradient(circle, rgba(59, 130, 246, 0.4) 25%, transparent 25%) !important;
    }

    .highlight-capture {
      background: radial-gradient(circle, transparent 50%, rgba(239, 68, 68, 0.5) 50%) !important;
    }

    .highlight-last-move {
      background-color: rgba(234, 179, 8, 0.4) !important;
    }

    /* Pre-move highlights (orange/amber for queued moves) */
    .highlight-premove-from {
      box-shadow: inset 0 0 0 4px var(--accent-yellow) !important;
      background-color: rgba(234, 179, 8, 0.3) !important;
    }

    .highlight-premove-to {
      background-color: rgba(234, 179, 8, 0.5) !important;
    }

    .highlight-premove-pending {
      box-shadow: inset 0 0 0 4px rgba(234, 179, 8, 0.7) !important;
    }

    /* Pre-move queue indicator */
    .premove-badge {
      position: absolute;
      top: 2px;
      right: 2px;
      background: var(--accent-yellow);
      color: #1e293b;
      font-size: 0.65rem;
      font-weight: 700;
      padding: 1px 4px;
      border-radius: 4px;
      z-index: 100;
    }

    .messages {
      flex: 1;
      min-height: 0; /* Important for flex overflow */
      overflow-y: auto;
      padding: 16px;
    }

    .message {
      margin-bottom: 12px;
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .message.user {
      background: var(--accent-blue);
      margin-left: 40px;
    }

    .message.assistant {
      background: var(--bg-tertiary);
      margin-right: 40px;
    }

    .message.system {
      background: rgba(234, 179, 8, 0.15);
      color: var(--accent-yellow);
      text-align: center;
      font-size: 0.8rem;
    }

    .message-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .move-badge {
      background: var(--accent-green);
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-weight: 600;
      font-size: 0.7rem;
    }

    .thinking-indicator {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-tertiary);
      border-radius: 12px;
      margin-right: 40px;
      color: var(--text-secondary);
      font-size: 0.85rem;
    }

    .thinking-dots {
      display: flex;
      gap: 4px;
    }

    .thinking-dots span {
      width: 6px;
      height: 6px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
    .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }

    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1); }
    }

    /* Voice Input */
    .voice-input-area {
      flex-shrink: 0;
      padding: 16px;
      border-top: 1px solid var(--border-color);
    }

    .mic-button {
      width: 100%;
      padding: 16px;
      border-radius: 12px;
      border: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      transition: all 0.2s;
    }

    .mic-button.idle {
      background: var(--accent-blue);
      color: white;
    }

    .mic-button.listening {
      background: var(--accent-red);
      color: white;
      animation: pulse 1.5s infinite;
    }

    .mic-button.speaking {
      background: var(--accent-green);
      color: white;
    }

    .mic-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .transcript {
      margin-top: 8px;
      padding: 10px;
      background: var(--bg-primary);
      border-radius: 8px;
      min-height: 36px;
      font-size: 0.875rem;
      color: var(--text-secondary);
      font-style: italic;
    }

    .chat-input-area {
      flex-shrink: 0;
      padding: 0 16px 16px;
      display: flex;
      gap: 8px;
    }

    .chat-input-area input {
      flex: 1;
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 0.9rem;
    }

    .chat-input-area input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .chat-input-area button {
      padding: 10px 16px;
      border-radius: 8px;
      border: none;
      background: var(--accent-blue);
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    .chat-input-area button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Move History */
    .move-history {
      flex-shrink: 0;
      padding: 12px 16px;
      border-top: 1px solid var(--border-color);
      max-height: 120px;
      overflow-y: auto;
    }

    .move-history h4 {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .moves-list {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.8rem;
    }

    .move-pair {
      display: flex;
      margin-bottom: 2px;
    }

    .move-num { color: var(--text-muted); width: 28px; }
    .move-white { color: var(--text-primary); width: 56px; }
    .move-black { color: var(--text-secondary); width: 56px; }

    /* Difficulty Slider */
    .difficulty-group {
      margin-bottom: 24px;
    }

    .difficulty-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .difficulty-label {
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.875rem;
    }

    .difficulty-value {
      font-weight: 600;
      color: var(--accent-blue);
      font-size: 0.875rem;
    }

    .difficulty-slider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: var(--bg-primary);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .difficulty-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent-blue);
      cursor: pointer;
      transition: transform 0.2s;
    }

    .difficulty-slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .difficulty-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent-blue);
      cursor: pointer;
      border: none;
    }

    .difficulty-marks {
      display: flex;
      justify-content: space-between;
      margin-top: 4px;
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .stats-preview {
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 0.8rem;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .stats-row:last-child {
      margin-bottom: 0;
    }

    .stats-row .label {
      color: var(--text-muted);
    }

    .stats-row .value {
      color: var(--text-primary);
      font-weight: 500;
    }

    /* Game Over Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s;
    }

    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--bg-secondary);
      border-radius: 16px;
      padding: 32px;
      max-width: 420px;
      width: 90%;
      border: 1px solid var(--border-color);
      transform: scale(0.9);
      transition: transform 0.3s;
    }

    .modal-overlay.active .modal {
      transform: scale(1);
    }

    .modal h2 {
      text-align: center;
      margin-bottom: 8px;
      font-size: 1.5rem;
    }

    .modal .result-message {
      text-align: center;
      color: var(--text-secondary);
      margin-bottom: 24px;
    }

    .modal .result-icon {
      font-size: 4rem;
      text-align: center;
      margin-bottom: 16px;
    }

    .modal .game-stats {
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .modal .name-input {
      width: 100%;
      padding: 12px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 1rem;
      margin-bottom: 16px;
    }

    .modal .name-input:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .modal .button-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .modal .btn {
      padding: 14px;
      border-radius: 10px;
      border: none;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .modal .btn-primary {
      background: var(--accent-blue);
      color: white;
    }

    .modal .btn-primary:hover {
      background: #2563eb;
    }

    .modal .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .modal .btn-secondary:hover {
      background: #475569;
    }

    .modal .btn-ghost {
      background: transparent;
      color: var(--text-muted);
    }

    .modal .btn-ghost:hover {
      color: var(--text-primary);
    }

    /* Analysis Modal */
    .analysis-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 20px;
      margin-top: 16px;
    }

    @media (max-width: 700px) {
      .analysis-layout {
        grid-template-columns: 1fr;
      }
    }

    .analysis-board-container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #analysis-board {
      width: 100%;
      max-width: 280px;
    }

    .replay-controls {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .replay-controls button {
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      color: var(--text-primary);
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
    }

    .replay-controls button:hover {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
    }

    .replay-controls button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .move-counter {
      text-align: center;
      font-size: 0.85rem;
      color: var(--text-secondary);
    }

    .analysis-content {
      max-height: 350px;
      overflow-y: auto;
    }

    .move-analysis {
      padding: 10px 12px;
      margin-bottom: 6px;
      border-radius: 8px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
      border-left: 4px solid transparent;
    }

    .move-analysis:hover {
      transform: translateX(4px);
    }

    .move-analysis.selected {
      box-shadow: 0 0 0 2px var(--accent-blue);
    }

    /* Positive classifications */
    .move-analysis.brilliant {
      background: linear-gradient(135deg, rgba(168, 85, 247, 0.3), rgba(236, 72, 153, 0.3));
      border-left-color: #a855f7;
    }
    .move-analysis.great {
      background: rgba(59, 130, 246, 0.25);
      border-left-color: #3b82f6;
    }
    .move-analysis.best {
      background: rgba(34, 197, 94, 0.2);
      border-left-color: #22c55e;
    }
    .move-analysis.good {
      background: rgba(34, 197, 94, 0.1);
      border-left-color: #4ade80;
    }
    .move-analysis.book {
      background: rgba(148, 163, 184, 0.2);
      border-left-color: #94a3b8;
    }

    /* Negative classifications */
    .move-analysis.inaccuracy {
      background: rgba(234, 179, 8, 0.2);
      border-left-color: #eab308;
    }
    .move-analysis.mistake {
      background: rgba(249, 115, 22, 0.25);
      border-left-color: #f97316;
    }
    .move-analysis.blunder {
      background: rgba(239, 68, 68, 0.25);
      border-left-color: #ef4444;
    }

    .move-classification {
      font-weight: 600;
      text-transform: capitalize;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
    }

    .move-classification.brilliant { background: #a855f7; color: white; }
    .move-classification.great { background: #3b82f6; color: white; }
    .move-classification.best { background: #22c55e; color: white; }
    .move-classification.good { background: #4ade80; color: #1e293b; }
    .move-classification.book { background: #94a3b8; color: #1e293b; }
    .move-classification.inaccuracy { background: #eab308; color: #1e293b; }
    .move-classification.mistake { background: #f97316; color: white; }
    .move-classification.blunder { background: #ef4444; color: white; }

    .move-eval {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .analysis-stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-bottom: 16px;
    }

    .stat-card {
      background: var(--bg-primary);
      padding: 10px;
      border-radius: 8px;
      text-align: center;
    }

    .stat-card .stat-value {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .stat-card .stat-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .stat-card.brilliant .stat-value { color: #a855f7; }
    .stat-card.great .stat-value { color: #3b82f6; }
    .stat-card.best .stat-value { color: #22c55e; }
    .stat-card.inaccuracy .stat-value { color: #eab308; }
    .stat-card.mistake .stat-value { color: #f97316; }
    .stat-card.blunder .stat-value { color: #ef4444; }

    /* Utilities */
    .hidden { display: none !important; }

    /* Training Mode Styles */
    .opening-card {
      background: var(--bg-primary);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      border-left: 4px solid var(--bg-tertiary);
      transition: all 0.2s;
    }

    .opening-card:hover {
      border-color: var(--accent-green);
      transform: translateX(4px);
    }

    .opening-card.white-opening {
      border-left-color: #f8fafc;
    }

    .opening-card.black-opening {
      border-left-color: #475569;
    }

    .opening-card .opening-name {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 1rem;
    }

    .opening-card .opening-desc {
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 8px;
      line-height: 1.4;
    }

    .opening-card .opening-meta {
      display: flex;
      gap: 12px;
      font-size: 0.75rem;
      color: var(--text-muted);
      align-items: center;
    }

    .mastery-badge {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .mastery-badge.beginner { background: var(--bg-tertiary); color: var(--text-secondary); }
    .mastery-badge.learning { background: rgba(234, 179, 8, 0.2); color: #eab308; }
    .mastery-badge.proficient { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
    .mastery-badge.mastered { background: rgba(34, 197, 94, 0.2); color: #22c55e; }

    .opening-section-header {
      font-size: 0.75rem;
      color: var(--text-muted);
      text-transform: uppercase;
      margin: 16px 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--bg-tertiary);
    }

    /* Review Mode Styles */
    .review-feedback {
      padding: 16px;
      border-radius: 8px;
      margin-bottom: 12px;
    }

    .review-feedback.correct {
      background: rgba(34, 197, 94, 0.15);
      border-left: 4px solid var(--accent-green);
    }

    .review-feedback.incorrect {
      background: rgba(239, 68, 68, 0.15);
      border-left: 4px solid var(--accent-red);
    }

    .review-feedback .feedback-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .review-feedback .feedback-explanation {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .leitner-box-indicator {
      display: flex;
      gap: 4px;
    }

    .leitner-box {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
    }

    .leitner-box.active {
      background: #8b5cf6;
      color: white;
    }

    .leitner-box.mastered {
      background: var(--accent-green);
      color: white;
    }

    /* Training completion overlay */
    .training-complete-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      border-radius: 8px;
    }

    .training-complete-overlay h2 {
      color: var(--accent-green);
      margin-bottom: 16px;
    }

    .training-complete-overlay .stats {
      color: var(--text-secondary);
      margin-bottom: 24px;
      text-align: center;
    }

    .btn-ghost {
      background: transparent;
      border: 1px solid var(--bg-tertiary);
      color: var(--text-secondary);
      padding: 8px 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-ghost:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <h1>Voice Chess</h1>
      <div class="header-status">
        <div class="connection-status">
          <span class="connection-dot" id="connection-dot"></span>
          <span id="connection-text">Connecting...</span>
        </div>
        <button id="new-game-btn" class="hidden" style="padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border-color); background: transparent; color: var(--text-secondary); cursor: pointer; font-size: 0.8rem;">New Game</button>
      </div>
    </header>

    <!-- Setup Screen -->
    <div id="setup-screen" class="setup-screen">
      <div class="setup-card">
        <h2>Start a Game</h2>

        <div id="error-container"></div>

        <div class="form-group">
          <label>Ollama Model</label>
          <select id="model-select">
            <option value="">Loading models...</option>
          </select>
        </div>

        <div class="form-group">
          <label>Voice</label>
          <div style="display: flex; gap: 8px; align-items: center;">
            <select id="voice-select" style="flex: 1;">
              <option value="">Loading voices...</option>
            </select>
            <button id="voice-preview-btn" class="icon-btn" title="Preview voice" style="padding: 8px 12px; font-size: 1rem;">
              &#9658;
            </button>
          </div>
        </div>

        <div class="form-group">
          <label>Play as</label>
          <div class="color-picker">
            <button class="color-btn white selected" data-color="white">
              <span class="piece">&#9812;</span>
              White
            </button>
            <button class="color-btn black" data-color="black">
              <span class="piece">&#9818;</span>
              Black
            </button>
          </div>
        </div>

        <div class="difficulty-group">
          <div class="difficulty-header">
            <span class="difficulty-label">Difficulty</span>
            <span id="difficulty-value" class="difficulty-value">Intermediate (10)</span>
          </div>
          <input type="range" id="difficulty-slider" class="difficulty-slider" min="1" max="20" value="10">
          <div class="difficulty-marks">
            <span>Beginner</span>
            <span>Easy</span>
            <span>Medium</span>
            <span>Hard</span>
            <span>Master</span>
          </div>
        </div>

        <div id="stats-preview" class="stats-preview">
          <div class="stats-row">
            <span class="label">Games Played</span>
            <span id="stat-games" class="value">0</span>
          </div>
          <div class="stats-row">
            <span class="label">Win Rate</span>
            <span id="stat-winrate" class="value">0%</span>
          </div>
          <div class="stats-row">
            <span class="label">Record (W/L/D)</span>
            <span id="stat-record" class="value">0/0/0</span>
          </div>
        </div>

        <button id="start-btn" class="start-btn" disabled>Start New Game</button>
        <button id="load-game-btn" class="start-btn" style="background: var(--bg-tertiary); margin-top: 8px;">Load Saved Game</button>

        <div style="display: flex; gap: 8px; margin-top: 16px;">
          <button id="train-btn" class="start-btn" style="flex: 1; background: var(--accent-green);">Train Openings</button>
          <button id="review-btn" class="start-btn" style="flex: 1; background: #8b5cf6;">Review</button>
        </div>
      </div>
    </div>

    <!-- Training Mode Modal -->
    <div id="training-modal" class="modal-overlay">
      <div class="modal" style="max-width: 600px;">
        <h2>Training Mode</h2>
        <p style="color: var(--text-secondary); margin-bottom: 16px;">Select an opening to practice</p>

        <div id="training-stats-preview" class="stats-preview" style="margin-bottom: 16px;">
          <div class="stats-row">
            <span class="label">Sessions Today</span>
            <span id="training-sessions-today" class="value">0 / 5</span>
          </div>
        </div>

        <div id="openings-list" style="max-height: 350px; overflow-y: auto;">
          <div style="text-align: center; padding: 20px; color: var(--text-muted);">Loading openings...</div>
        </div>

        <div class="button-group" style="margin-top: 16px;">
          <button id="close-training-modal-btn" class="btn btn-secondary">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Training Screen -->
    <div id="training-screen" class="game-screen">
      <div class="board-panel">
        <div class="game-info">
          <div id="training-opening-name" class="turn-badge" style="background: var(--accent-green);">Opening Name</div>
          <div id="training-progress-text" class="status-text">Move 1 of 8</div>
        </div>

        <div class="board-wrapper">
          <div id="training-board"></div>
        </div>

        <div id="training-hint-area" style="margin-top: 16px; padding: 16px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-green);">
          <div id="training-hint-label" style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 4px; text-transform: uppercase;">
            Next Move
          </div>
          <div id="training-hint-move" style="font-size: 1.5rem; font-weight: 600; color: var(--accent-green);">
            d4
          </div>
          <div id="training-hint-explanation" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 8px;">
            Control the center with your d-pawn
          </div>
        </div>
      </div>

      <div class="chat-panel">
        <div class="chat-header">
          <h3>Training</h3>
          <div class="voice-controls">
            <button id="training-speaker-toggle" class="icon-btn active" title="Voice (click to mute)">VOL</button>
            <button id="training-mic-btn" class="icon-btn" title="Ask a question">MIC</button>
          </div>
        </div>

        <div id="training-messages" class="messages"></div>

        <div id="training-voice-input" class="voice-input-area" style="display: none; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; margin: 0 16px;">
          <div id="training-transcript" class="transcript" style="min-height: 40px; padding: 8px; background: var(--bg-primary); border-radius: 4px; margin-bottom: 8px; font-size: 0.9rem; color: var(--text-secondary);"></div>
          <div style="display: flex; gap: 8px;">
            <input type="text" id="training-chat-input" placeholder="Ask about this opening..." style="flex: 1; padding: 8px 12px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary);">
            <button id="training-send-btn" class="btn btn-primary" style="padding: 8px 16px;">Ask</button>
          </div>
        </div>

        <div style="padding: 16px;">
          <div id="training-accuracy-section" style="margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; font-size: 0.875rem; margin-bottom: 4px;">
              <span>Accuracy</span>
              <span id="training-accuracy-value">100%</span>
            </div>
            <div style="height: 8px; background: var(--bg-primary); border-radius: 4px; overflow: hidden;">
              <div id="training-accuracy-bar" style="height: 100%; background: var(--accent-green); width: 100%; transition: width 0.3s;"></div>
            </div>
          </div>

          <div id="training-progress-section" style="margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; font-size: 0.875rem; margin-bottom: 4px;">
              <span>Progress</span>
              <span id="training-progress-value">0%</span>
            </div>
            <div style="height: 8px; background: var(--bg-primary); border-radius: 4px; overflow: hidden;">
              <div id="training-progress-bar" style="height: 100%; background: var(--accent-blue); width: 0%; transition: width 0.3s;"></div>
            </div>
          </div>

          <button id="end-training-btn" class="btn btn-secondary" style="width: 100%;">End Training</button>
        </div>
      </div>
    </div>

    <!-- Review Mode Modal -->
    <div id="review-modal" class="modal-overlay">
      <div class="modal" style="max-width: 450px;">
        <h2>Spaced Repetition Review</h2>
        <p style="color: var(--text-secondary); margin-bottom: 16px;">Practice positions to improve your memory</p>

        <div id="review-stats-preview" class="stats-preview">
          <div class="stats-row">
            <span class="label">Cards Due</span>
            <span id="review-due-count" class="value">0</span>
          </div>
          <div class="stats-row">
            <span class="label">Total Cards</span>
            <span id="review-total-count" class="value">0</span>
          </div>
          <div class="stats-row">
            <span class="label">Mastered</span>
            <span id="review-mastered-count" class="value">0</span>
          </div>
        </div>

        <div class="button-group" style="margin-top: 16px;">
          <button id="start-review-btn" class="btn btn-primary">Start Review</button>
          <button id="close-review-modal-btn" class="btn btn-secondary">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Review Screen -->
    <div id="review-screen" class="game-screen">
      <div class="board-panel">
        <div class="game-info">
          <div id="review-card-type" class="turn-badge" style="background: #8b5cf6;">Opening</div>
          <div id="review-progress-text" class="status-text">Card 1 of 10</div>
        </div>

        <div class="board-wrapper">
          <div id="review-board"></div>
        </div>

        <div id="review-prompt" style="margin-top: 16px; text-align: center; padding: 16px; background: var(--bg-secondary); border-radius: 8px;">
          <p style="color: var(--text-secondary); margin: 0;">Find the best move in this position</p>
          <p id="review-opening-hint" style="color: var(--text-muted); font-size: 0.85rem; margin-top: 8px;"></p>
        </div>
      </div>

      <div class="chat-panel">
        <div class="chat-header">
          <h3>Review</h3>
          <div class="voice-controls">
            <button id="review-speaker-toggle" class="icon-btn active" title="Voice (click to mute)">VOL</button>
            <button id="review-mic-btn" class="icon-btn" title="Speak your move">MIC</button>
          </div>
        </div>

        <div id="review-feedback-area" class="messages"></div>

        <div style="padding: 16px;">
          <div id="review-session-stats" style="margin-bottom: 16px;">
            <div class="stats-row">
              <span class="label" style="color: var(--accent-green);">Correct</span>
              <span id="review-correct-count" class="value">0</span>
            </div>
            <div class="stats-row">
              <span class="label" style="color: var(--accent-red);">Incorrect</span>
              <span id="review-incorrect-count" class="value">0</span>
            </div>
          </div>

          <div id="review-leitner-box" style="margin-bottom: 16px; display: none;">
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 4px;">Leitner Box</div>
            <div class="leitner-box-indicator">
              <div class="leitner-box" data-box="1">1</div>
              <div class="leitner-box" data-box="2">2</div>
              <div class="leitner-box" data-box="3">3</div>
              <div class="leitner-box" data-box="4">4</div>
              <div class="leitner-box" data-box="5">5</div>
              <div class="leitner-box" data-box="6">6</div>
            </div>
          </div>

          <button id="skip-review-card-btn" class="btn btn-ghost" style="width: 100%;">Skip This Card</button>
          <button id="end-review-btn" class="btn btn-secondary" style="width: 100%; margin-top: 8px;">End Review</button>
        </div>
      </div>
    </div>

    <!-- Load Game Modal -->
    <div id="load-game-modal" class="modal-overlay">
      <div class="modal" style="max-width: 500px;">
        <h2>Load Saved Game</h2>
        <div id="saved-games-list" style="max-height: 400px; overflow-y: auto; margin: 16px 0;">
          <div style="text-align: center; padding: 20px; color: var(--text-muted);">Loading...</div>
        </div>
        <div class="button-group">
          <button id="close-load-modal-btn" class="btn btn-secondary">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="game-screen">
      <div class="board-panel">
        <div class="game-info">
          <div id="turn-badge" class="turn-badge white">White to move</div>
          <div id="status-text" class="status-text">Your turn</div>
        </div>

        <div class="board-wrapper">
          <div id="board"></div>
        </div>

        <div class="board-controls">
          <button id="undo-btn">Undo</button>
          <button id="hint-btn">Hint</button>
          <button id="analyze-btn">Analyze</button>
        </div>
      </div>

      <div class="chat-panel">
        <div class="chat-header">
          <h3>Chat</h3>
          <div class="voice-controls">
            <button id="mic-toggle" class="icon-btn active" title="Microphone (click to mute)">MIC</button>
            <button id="speaker-toggle" class="icon-btn active" title="Speaker (click to mute)">VOL</button>
            <button id="skip-btn" class="icon-btn" title="Skip current speech">&gt;&gt;</button>
            <button id="replay-move-btn" class="icon-btn" title="Replay last AI move">&#x21bb;</button>
          </div>
        </div>

        <div id="messages" class="messages"></div>

        <div class="voice-input-area">
          <button id="mic-btn" class="mic-button idle">
            <span id="mic-icon">&#127908;</span>
            <span id="mic-text">Click to Speak</span>
          </button>
          <div id="transcript" class="transcript"></div>
        </div>

        <div class="chat-input-area">
          <input type="text" id="chat-input" placeholder="Or type here..." />
          <button id="send-btn">Send</button>
        </div>

        <div class="move-history">
          <h4>Moves</h4>
          <div id="moves-list" class="moves-list"></div>
        </div>
      </div>
    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-overlay">
      <div class="modal">
        <div id="result-icon" class="result-icon"></div>
        <h2 id="modal-title">Game Over</h2>
        <p id="modal-message" class="result-message"></p>

        <div class="game-stats">
          <div class="stats-row">
            <span class="label">Moves Played</span>
            <span id="modal-moves" class="value">0</span>
          </div>
          <div class="stats-row">
            <span class="label">Your Color</span>
            <span id="modal-color" class="value">White</span>
          </div>
          <div class="stats-row">
            <span class="label">New Difficulty</span>
            <span id="modal-difficulty" class="value">Intermediate</span>
          </div>
        </div>

        <input type="text" id="game-name-input" class="name-input" placeholder="Name this game (optional)">

        <div class="button-group">
          <button id="save-review-btn" class="btn btn-primary">Save & Review Game</button>
          <button id="save-new-btn" class="btn btn-secondary">Save & New Game</button>
          <button id="skip-save-btn" class="btn btn-ghost">Skip & New Game</button>
        </div>
      </div>
    </div>

    <!-- Analysis Modal -->
    <div id="analysis-modal" class="modal-overlay">
      <div class="modal" style="max-width: 800px;">
        <h2>Game Analysis</h2>
        <div id="analysis-summary" class="result-message"></div>

        <div class="analysis-stats-grid">
          <div class="stat-card brilliant">
            <div id="stat-brilliant" class="stat-value">0</div>
            <div class="stat-label">Brilliant</div>
          </div>
          <div class="stat-card great">
            <div id="stat-great" class="stat-value">0</div>
            <div class="stat-label">Great</div>
          </div>
          <div class="stat-card best">
            <div id="stat-best" class="stat-value">0</div>
            <div class="stat-label">Best</div>
          </div>
          <div class="stat-card inaccuracy">
            <div id="stat-inaccuracy" class="stat-value">0</div>
            <div class="stat-label">Inaccuracies</div>
          </div>
          <div class="stat-card mistake">
            <div id="stat-mistake" class="stat-value">0</div>
            <div class="stat-label">Mistakes</div>
          </div>
          <div class="stat-card blunder">
            <div id="stat-blunder" class="stat-value">0</div>
            <div class="stat-label">Blunders</div>
          </div>
        </div>

        <div class="analysis-layout">
          <div class="analysis-board-container">
            <div id="analysis-board"></div>
            <div class="replay-controls">
              <button id="replay-first" title="First move">⏮</button>
              <button id="replay-prev" title="Previous move">◀</button>
              <button id="replay-next" title="Next move">▶</button>
              <button id="replay-last" title="Last move">⏭</button>
            </div>
            <div id="move-counter" class="move-counter">Starting position</div>
          </div>

          <div id="analysis-moves" class="analysis-content"></div>
        </div>

        <div class="button-group" style="margin-top: 20px;">
          <button id="close-analysis-btn" class="btn btn-secondary">Close</button>
          <button id="analysis-new-game-btn" class="btn btn-primary">New Game</button>
        </div>
      </div>
    </div>
  </div>

  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
  <script>
    // ===========================================
    // Voice Chess - Frontend Application
    // ===========================================

    const WS_URL = `ws://${window.location.host}/ws/default`;
    const API_URL = window.location.origin;

    // State
    let ws = null;
    let board = null;
    let playerColor = 'white';
    let selectedModel = '';
    let isThinking = false;

    // Voice
    let recognition = null;
    let selectedVoice = 'ryan';  // Default neural voice
    let voiceEnabled = true;
    let isListening = false;
    let isSpeaking = false;
    let currentAudio = null;

    // Always-on microphone state
    let alwaysOnMode = true;  // Default to always-on
    let silenceTimer = null;
    let accumulatedTranscript = '';
    const SILENCE_TIMEOUT = 1500;  // 1.5 seconds of silence triggers submission

    // Current game state from server
    let gameState = null;

    // Difficulty and stats
    let currentDifficulty = 10;
    let pendingGameOver = null;  // Stores game over data for modal

    // Analysis replay state
    let analysisBoard = null;
    let analysisData = null;
    let currentMoveIndex = -1;  // -1 = starting position

    // Click-to-move state
    let selectedSquare = null;
    let legalMovesForSelected = [];

    // Pre-move state
    const MAX_PREMOVES = 20;
    let preMoveQueue = [];  // Array of { from: 'e2', to: 'e4' }
    let preMovePendingSquare = null;  // Square selected for pre-move

    // Last AI move for replay
    let lastAIMove = null;  // { from: 'e2', to: 'e4', piece: 'wP' }

    // ===========================================
    // Initialization
    // ===========================================

    document.addEventListener('DOMContentLoaded', async () => {
      await Promise.all([
        loadModels(),
        loadVoices(),
        loadDifficultyAndStats()
      ]);
      setupEventListeners();
      setupSpeechRecognition();
      connectWebSocket();
    });

    async function loadDifficultyAndStats() {
      try {
        // Load current difficulty
        const diffResponse = await fetch(`${API_URL}/api/difficulty`);
        const diffData = await diffResponse.json();
        currentDifficulty = diffData.level;

        const slider = document.getElementById('difficulty-slider');
        slider.value = currentDifficulty;
        updateDifficultyDisplay(currentDifficulty);

        // Load stats
        const statsResponse = await fetch(`${API_URL}/api/stats`);
        const stats = await statsResponse.json();

        document.getElementById('stat-games').textContent = stats.games_played;
        document.getElementById('stat-winrate').textContent = `${stats.win_rate}%`;
        document.getElementById('stat-record').textContent = `${stats.wins}/${stats.losses}/${stats.draws}`;

      } catch (err) {
        console.error('Failed to load difficulty/stats:', err);
      }
    }

    function updateDifficultyDisplay(level) {
      let name;
      if (level <= 3) name = 'Beginner';
      else if (level <= 6) name = 'Easy';
      else if (level <= 10) name = 'Intermediate';
      else if (level <= 14) name = 'Advanced';
      else if (level <= 17) name = 'Expert';
      else name = 'Master';

      document.getElementById('difficulty-value').textContent = `${name} (${level})`;
    }

    async function loadModels() {
      try {
        const response = await fetch(`${API_URL}/api/models`);
        const data = await response.json();
        const select = document.getElementById('model-select');
        select.innerHTML = '';

        if (data.models && data.models.length > 0) {
          // Prefer llama3.2 or similar
          const preferred = ['llama3.2', 'llama3.1', 'llama3', 'mistral'];
          data.models.sort((a, b) => {
            const aIdx = preferred.findIndex(p => a.toLowerCase().includes(p));
            const bIdx = preferred.findIndex(p => b.toLowerCase().includes(p));
            if (aIdx >= 0 && bIdx < 0) return -1;
            if (bIdx >= 0 && aIdx < 0) return 1;
            return 0;
          });

          data.models.forEach(model => {
            const option = document.createElement('option');
            option.value = model;
            option.textContent = model;
            select.appendChild(option);
          });

          selectedModel = data.models[0];
          document.getElementById('start-btn').disabled = false;
        } else {
          select.innerHTML = '<option value="">No models found</option>';
          showError('No Ollama models found. Run: ollama pull llama3.2');
        }
      } catch (err) {
        document.getElementById('model-select').innerHTML = '<option value="">Connection failed</option>';
        showError('Cannot connect to server. Is it running?');
      }
    }

    async function loadVoices() {
      try {
        const response = await fetch(`${API_URL}/api/voices`);
        const data = await response.json();
        const select = document.getElementById('voice-select');
        select.innerHTML = '';

        if (data.voices && data.voices.length > 0) {
          data.voices.forEach(voice => {
            const option = document.createElement('option');
            option.value = voice.key;
            option.textContent = `${voice.name} - ${voice.description}`;
            select.appendChild(option);
          });
          selectedVoice = data.voices[0].key;
        }
      } catch (err) {
        console.error('Failed to load voices:', err);
        // Fallback
        const select = document.getElementById('voice-select');
        select.innerHTML = '<option value="ryan">Ryan (British Male)</option>';
        selectedVoice = 'ryan';
      }
    }

    function setupSpeechRecognition() {
      if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
        const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SR();
        recognition.continuous = true;  // Keep listening
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        recognition.onresult = (event) => {
          // Clear any pending silence timer
          if (silenceTimer) {
            clearTimeout(silenceTimer);
            silenceTimer = null;
          }

          // Get the latest transcript
          let finalTranscript = '';
          let interimTranscript = '';

          for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            if (result.isFinal) {
              finalTranscript += result[0].transcript;
            } else {
              interimTranscript += result[0].transcript;
            }
          }

          // Update display with both final and interim
          const displayText = (accumulatedTranscript + finalTranscript + interimTranscript).trim();
          document.getElementById('transcript').textContent = displayText;

          // Accumulate final transcripts
          if (finalTranscript) {
            accumulatedTranscript += finalTranscript;
          }

          // Start silence timer - if no more speech for SILENCE_TIMEOUT, submit
          if (accumulatedTranscript.trim() || interimTranscript.trim()) {
            silenceTimer = setTimeout(() => {
              const toSend = accumulatedTranscript.trim();
              if (toSend) {
                console.log('Silence detected, submitting:', toSend);
                accumulatedTranscript = '';
                document.getElementById('transcript').textContent = '';

                // Pause listening while processing
                pauseListening();
                sendChat(toSend);
              }
            }, SILENCE_TIMEOUT);
          }
        };

        recognition.onerror = (event) => {
          console.error('Speech error:', event.error);
          // Don't stop on no-speech error in always-on mode
          if (event.error === 'no-speech') {
            // Just restart if in always-on mode
            if (alwaysOnMode && !isSpeaking && !isThinking) {
              restartListening();
            }
            return;
          }
          if (event.error === 'not-allowed') {
            addMessage('system', 'Microphone access denied. Please allow and reload.');
            alwaysOnMode = false;
            updateMicButton();
          }
          if (event.error === 'aborted') {
            // User or system aborted - this is fine
            return;
          }
          stopListening();
        };

        recognition.onend = () => {
          // Auto-restart if in always-on mode and not speaking/thinking
          if (alwaysOnMode && !isSpeaking && !isThinking) {
            setTimeout(() => {
              if (alwaysOnMode && !isSpeaking && !isThinking) {
                restartListening();
              }
            }, 100);
          } else {
            isListening = false;
            updateMicButton();
          }
        };
      }
    }

    function restartListening() {
      if (!recognition || isSpeaking || isThinking) return;

      try {
        recognition.start();
        isListening = true;
        updateMicButton();
      } catch (e) {
        // Already started or other error
        console.log('Recognition restart error:', e.message);
      }
    }

    function pauseListening() {
      // Temporarily pause without disabling always-on mode
      if (recognition && isListening) {
        try {
          recognition.stop();
        } catch (e) {}
        isListening = false;
      }
      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }
      accumulatedTranscript = '';
    }

    function updateMicButton() {
      const btn = document.getElementById('mic-btn');
      const icon = document.getElementById('mic-icon');
      const text = document.getElementById('mic-text');

      // Update main mic button in voice input area
      if (isSpeaking) {
        btn.className = 'mic-button speaking';
        icon.innerHTML = '))';
        text.textContent = 'Speaking...';
      } else if (isListening) {
        btn.className = 'mic-button listening';
        icon.innerHTML = '((o))';
        text.textContent = 'Listening...';
      } else if (alwaysOnMode) {
        btn.className = 'mic-button idle';
        icon.innerHTML = '(o)';
        text.textContent = 'Mic paused...';
      } else {
        btn.className = 'mic-button idle';
        icon.innerHTML = '(x)';
        text.textContent = 'Mic muted';
      }

      // Update header mic toggle button
      const micToggle = document.getElementById('mic-toggle');
      if (micToggle) {
        if (alwaysOnMode) {
          micToggle.classList.add('active');
          micToggle.classList.remove('muted');
          micToggle.title = 'Microphone (click to mute)';
        } else {
          micToggle.classList.remove('active');
          micToggle.classList.add('muted');
          micToggle.title = 'Microphone muted (click to unmute)';
        }
      }
    }

    // ===========================================
    // WebSocket
    // ===========================================

    function connectWebSocket() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('WebSocket connected');
        document.getElementById('connection-dot').classList.add('connected');
        document.getElementById('connection-text').textContent = 'Connected';
      };

      ws.onclose = () => {
        console.log('WebSocket disconnected');
        document.getElementById('connection-dot').classList.remove('connected');
        document.getElementById('connection-text').textContent = 'Disconnected';

        // Reconnect after delay
        setTimeout(connectWebSocket, 3000);
      };

      ws.onerror = (err) => {
        console.error('WebSocket error:', err);
      };

      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleServerMessage(data);
      };
    }

    function handleServerMessage(data) {
      console.log('Server message:', data.type, data);

      switch (data.type) {
        case 'game_state':
          gameState = data.state;
          clearAllPreMoves();  // Clear pre-moves on new/loaded game
          updateBoard();
          updateGameInfo();
          break;

        case 'move_result':
          if (data.result.success) {
            gameState = data.result.state;
            updateBoard();
            updateGameInfo();
          } else {
            addMessage('system', data.result.error);
          }
          break;

        case 'ai_thinking':
          isThinking = data.thinking;
          updateStatus();
          if (data.thinking) {
            showThinking();
            pauseListening();  // Pause while AI thinks
          } else {
            hideThinking();
            // Note: Don't resume here - wait for ai_response to speak first
          }
          break;

        case 'ai_response':
          hideThinking();
          if (data.state) {
            gameState = data.state;
            updateBoard();
            updateGameInfo();
          }
          // Track last AI move for replay
          if (data.move && data.move_from && data.move_to) {
            lastAIMove = {
              from: data.move_from,
              to: data.move_to,
              san: data.move
            };
          }
          addMessage('assistant', data.message, data.move);
          // Show blunder feedback if present
          if (data.blunder_feedback) {
            addMessage('system', data.blunder_feedback);
          }
          speak(data.message);

          // Execute queued pre-moves if it's now player's turn
          if (preMoveQueue.length > 0 && gameState && gameState.turn === playerColor && !gameState.is_game_over) {
            // Small delay to let the board update visually
            setTimeout(() => executePreMoves(), 100);
          }
          break;

        case 'undo_result':
          if (data.result.success) {
            gameState = data.result.state;
            clearAllPreMoves();  // Clear pre-moves on undo
            updateBoard();
            updateGameInfo();
          }
          break;

        case 'game_over':
          // Update state and show game over modal
          if (data.state) {
            gameState = data.state;
            updateBoard();
            updateGameInfo();
          }
          // Clear pre-moves and pause listening
          clearAllPreMoves();
          pauseListening();
          showGameOverModal(data);
          break;

        case 'error':
          addMessage('system', data.message);
          break;
      }
    }

    function send(data) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('[WS SEND]', data);
        ws.send(JSON.stringify(data));
      } else {
        console.log('[WS SEND] WebSocket not open, cannot send:', data);
      }
    }

    // ===========================================
    // Event Listeners
    // ===========================================

    function setupEventListeners() {
      // Color selection
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          playerColor = btn.dataset.color;
        });
      });

      // Model selection
      document.getElementById('model-select').addEventListener('change', (e) => {
        selectedModel = e.target.value;
      });

      // Voice selection
      document.getElementById('voice-select').addEventListener('change', (e) => {
        selectedVoice = e.target.value;
      });

      // Voice preview button
      document.getElementById('voice-preview-btn').addEventListener('click', previewVoice);

      // Start game
      document.getElementById('start-btn').addEventListener('click', startGame);

      // Mic button (manual push-to-talk when mic is muted)
      document.getElementById('mic-btn').addEventListener('click', () => {
        if (!alwaysOnMode) {
          // Mic is muted - toggle listening on
          if (isListening) {
            pauseListening();
          } else {
            startListening();
          }
        }
      });

      // Mic toggle (mute/unmute microphone)
      document.getElementById('mic-toggle').addEventListener('click', (e) => {
        toggleMic();
      });

      // Speaker toggle (mute/unmute speaker)
      document.getElementById('speaker-toggle').addEventListener('click', (e) => {
        voiceEnabled = !voiceEnabled;
        updateSpeakerButton();
      });

      // Skip current speech
      document.getElementById('skip-btn').addEventListener('click', skipSpeaking);

      // Replay last AI move
      document.getElementById('replay-move-btn').addEventListener('click', replayLastAIMove);

      // Chat input
      document.getElementById('send-btn').addEventListener('click', () => {
        const input = document.getElementById('chat-input');
        if (input.value.trim()) {
          sendChat(input.value.trim());
          input.value = '';
        }
      });

      document.getElementById('chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          const input = e.target;
          if (input.value.trim()) {
            sendChat(input.value.trim());
            input.value = '';
          }
        }
      });

      // Board controls
      document.getElementById('undo-btn').addEventListener('click', () => {
        send({ type: 'undo' });
      });

      document.getElementById('hint-btn').addEventListener('click', () => {
        sendChat("Can you give me a hint?");
      });

      document.getElementById('analyze-btn').addEventListener('click', () => {
        sendChat("Can you analyze the current position?");
      });

      // New game button
      document.getElementById('new-game-btn').addEventListener('click', () => {
        stopSpeaking();
        showSetupScreen();
      });

      // Difficulty slider
      document.getElementById('difficulty-slider').addEventListener('input', (e) => {
        updateDifficultyDisplay(parseInt(e.target.value));
      });

      document.getElementById('difficulty-slider').addEventListener('change', async (e) => {
        const level = parseInt(e.target.value);
        currentDifficulty = level;

        try {
          await fetch(`${API_URL}/api/difficulty`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ level })
          });
        } catch (err) {
          console.error('Failed to update difficulty:', err);
        }
      });

      // Game over modal buttons
      document.getElementById('save-review-btn').addEventListener('click', async () => {
        await saveGameResult();
        closeGameOverModal();
        showAnalysisModal();
      });

      document.getElementById('save-new-btn').addEventListener('click', async () => {
        await saveGameResult();
        closeGameOverModal();
        showSetupScreen();
      });

      document.getElementById('skip-save-btn').addEventListener('click', () => {
        closeGameOverModal();
        showSetupScreen();
      });

      // Analysis modal buttons
      document.getElementById('close-analysis-btn').addEventListener('click', () => {
        closeAnalysisModal();
      });

      document.getElementById('analysis-new-game-btn').addEventListener('click', () => {
        closeAnalysisModal();
        showSetupScreen();
      });

      // Replay controls
      document.getElementById('replay-first').addEventListener('click', () => replayGoTo(-1));
      document.getElementById('replay-prev').addEventListener('click', () => replayGoTo(currentMoveIndex - 1));
      document.getElementById('replay-next').addEventListener('click', () => replayGoTo(currentMoveIndex + 1));
      document.getElementById('replay-last').addEventListener('click', () => {
        if (analysisData) replayGoTo(analysisData.moves.length - 1);
      });

      // Load game modal
      document.getElementById('load-game-btn').addEventListener('click', openLoadGameModal);
      document.getElementById('close-load-modal-btn').addEventListener('click', closeLoadGameModal);
    }

    function showSetupScreen() {
      stopSpeaking();
      document.getElementById('setup-screen').style.display = 'flex';
      document.getElementById('game-screen').classList.remove('active');
      document.getElementById('new-game-btn').classList.add('hidden');
      loadDifficultyAndStats(); // Refresh stats
    }

    // ===========================================
    // Game Functions
    // ===========================================

    async function startGame() {
      document.getElementById('setup-screen').style.display = 'none';
      document.getElementById('game-screen').classList.add('active');
      document.getElementById('new-game-btn').classList.remove('hidden');
      document.getElementById('messages').innerHTML = '';
      document.getElementById('moves-list').innerHTML = '';

      // Apply the selected difficulty to the engine
      const sliderValue = parseInt(document.getElementById('difficulty-slider').value);
      currentDifficulty = sliderValue;

      try {
        await fetch(`${API_URL}/api/difficulty`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ level: currentDifficulty })
        });
      } catch (err) {
        console.error('Failed to set difficulty:', err);
      }

      // Initialize board with click-to-move support
      const config = {
        draggable: true,
        position: 'start',
        orientation: playerColor,
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd,
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
      };

      board = Chessboard('board', config);
      $(window).resize(() => board.resize());

      // Add click-to-move and pre-move handlers
      setupClickToMove();
      setupPreMoveClearHandler();

      // Start game on server
      send({
        type: 'new_game',
        player_color: playerColor,
        model: selectedModel
      });

      // Initialize button states
      updateMicButton();
      updateSpeakerButton();

      // Auto-start always-on listening after a short delay
      setTimeout(() => {
        if (alwaysOnMode) {
          startListening();
        }
      }, 1000);
    }

    let dragStartedAt = null;  // Track when drag started to detect actual drags vs clicks

    function onDragStart(source, piece) {
      if (!gameState) return false;
      if (gameState.is_game_over) return false;

      // Check if it's player's piece
      const isWhitePiece = piece.search(/^w/) !== -1;
      const isOwnPiece = (playerColor === 'white' && isWhitePiece) ||
                         (playerColor === 'black' && !isWhitePiece);

      if (!isOwnPiece) return false;

      // Record drag start time to distinguish clicks from drags
      dragStartedAt = Date.now();

      // DON'T clear selection here - let the click handler manage selection
      // Only clear pre-move selection since we're starting a new interaction
      const isPlayerTurn = gameState.turn === playerColor;
      const isPreMoveMode = isThinking || !isPlayerTurn;
      if (isPreMoveMode) {
        clearPreMoveSelection();
      }

      return true;
    }

    function onDrop(source, target) {
      const dragDuration = dragStartedAt ? Date.now() - dragStartedAt : 0;
      const wasActualDrag = dragDuration > 150 || source !== target;  // >150ms or moved to different square

      console.log('[DROP] source:', source, 'target:', target, 'dragDuration:', dragDuration, 'wasActualDrag:', wasActualDrag);

      // If dropped on same square quickly, it's a click - let click handler deal with it
      if (source === target && dragDuration < 150) {
        return 'snapback';
      }

      // This was an actual drag - clear click-to-move selection
      clearSelection();

      const isPlayerTurn = gameState && gameState.turn === playerColor;
      const isPreMoveMode = isThinking || !isPlayerTurn;

      // === PRE-MOVE MODE (via drag) ===
      if (isPreMoveMode) {
        if (preMoveQueue.length < MAX_PREMOVES) {
          const preMove = { from: source, to: target };
          preMoveQueue.push(preMove);
          console.log('[PREMOVE] Queued pre-move via drag:', preMove, 'Queue length:', preMoveQueue.length);
          renderPreMoves();
          addMessage('system', `Pre-move queued: ${source} → ${target} (${preMoveQueue.length} in queue)`);
        } else {
          addMessage('system', `Max pre-moves reached (${MAX_PREMOVES}). Clear some first.`);
        }
        return 'snapback';  // Always snap back for pre-moves
      }

      // === NORMAL MOVE MODE ===
      // Check if this move is in the legal moves list
      const uciMove = source + target;
      const isLegal = gameState && gameState.legal_moves &&
                      gameState.legal_moves.some(m => m.startsWith(uciMove));

      if (isLegal) {
        // Send move to server - board will snap to new position
        send({ type: 'move', move: uciMove });
        return true; // Allow the drop - piece stays where dropped
      }

      return 'snapback'; // Illegal move - snap back
    }

    function onSnapEnd() {
      // Board position is managed by server updates
      // This ensures the visual matches the game state
      if (gameState) {
        board.position(gameState.fen, false); // false = no animation
      }
    }

    function updateBoard() {
      if (board && gameState) {
        board.position(gameState.fen);
        updateMovesList();
      }
    }

    function updateGameInfo() {
      if (!gameState) return;

      const turnBadge = document.getElementById('turn-badge');
      turnBadge.textContent = `${gameState.turn === 'white' ? 'White' : 'Black'} to move`;
      turnBadge.className = `turn-badge ${gameState.turn}`;

      updateStatus();
    }

    function updateStatus() {
      const statusEl = document.getElementById('status-text');

      if (!gameState) {
        statusEl.textContent = '';
        statusEl.className = 'status-text';
        return;
      }

      if (gameState.is_checkmate) {
        const winner = gameState.turn === 'white' ? 'Black' : 'White';
        statusEl.textContent = `Checkmate! ${winner} wins!`;
        statusEl.className = 'status-text game-over';
      } else if (gameState.is_stalemate) {
        statusEl.textContent = 'Stalemate - Draw';
        statusEl.className = 'status-text game-over';
      } else if (gameState.is_game_over) {
        statusEl.textContent = 'Game Over - Draw';
        statusEl.className = 'status-text game-over';
      } else if (gameState.is_check) {
        statusEl.textContent = 'Check!';
        statusEl.className = 'status-text check';
      } else if (isThinking) {
        statusEl.textContent = 'Thinking...';
        statusEl.className = 'status-text thinking';
      } else {
        const isPlayerTurn = gameState.turn === playerColor;
        statusEl.textContent = isPlayerTurn ? 'Your turn' : "Opponent's turn";
        statusEl.className = 'status-text';
      }
    }

    function updateMovesList() {
      if (!gameState) return;

      const container = document.getElementById('moves-list');
      container.innerHTML = '';

      const moves = gameState.moves || [];
      for (let i = 0; i < moves.length; i += 2) {
        const div = document.createElement('div');
        div.className = 'move-pair';
        div.innerHTML = `
          <span class="move-num">${Math.floor(i/2) + 1}.</span>
          <span class="move-white">${moves[i] || ''}</span>
          <span class="move-black">${moves[i + 1] || ''}</span>
        `;
        container.appendChild(div);
      }
      container.scrollTop = container.scrollHeight;
    }

    // ===========================================
    // Chat & Messages
    // ===========================================

    function sendChat(message) {
      if (!message.trim() || isThinking) return;

      // Pause listening while processing (don't disable always-on mode)
      pauseListening();
      addMessage('user', message);
      send({ type: 'chat', message: message });
    }

    function addMessage(role, content, move = null) {
      const container = document.getElementById('messages');
      const div = document.createElement('div');
      div.className = `message ${role}`;

      if (role === 'assistant') {
        div.innerHTML = `
          <div class="message-header">
            AI ${move ? `<span class="move-badge">${move}</span>` : ''}
          </div>
          ${content}
        `;
      } else {
        div.textContent = content;
      }

      container.appendChild(div);
      container.scrollTop = container.scrollHeight;
    }

    function showThinking() {
      const container = document.getElementById('messages');
      let indicator = document.getElementById('thinking-indicator');

      if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'thinking-indicator';
        indicator.className = 'thinking-indicator';
        indicator.innerHTML = `
          <div class="thinking-dots"><span></span><span></span><span></span></div>
          <span>Thinking...</span>
        `;
        container.appendChild(indicator);
      }
      container.scrollTop = container.scrollHeight;
    }

    function hideThinking() {
      const indicator = document.getElementById('thinking-indicator');
      if (indicator) indicator.remove();
    }

    // ===========================================
    // Voice
    // ===========================================

    function toggleListening() {
      // Toggle always-on mode
      alwaysOnMode = !alwaysOnMode;

      if (alwaysOnMode) {
        // Enable always-on mode
        startListening();
      } else {
        // Disable always-on mode
        stopListening();
      }
    }

    function startListening() {
      if (!recognition || isThinking || isSpeaking) {
        // Queue to start when ready
        return;
      }

      stopSpeaking();

      try {
        recognition.start();
        isListening = true;
        accumulatedTranscript = '';
      } catch (e) {
        console.log('Start listening error:', e.message);
      }

      updateMicButton();
    }

    function stopListening() {
      alwaysOnMode = false;

      if (recognition) {
        try { recognition.stop(); } catch (e) {}
      }
      isListening = false;

      if (silenceTimer) {
        clearTimeout(silenceTimer);
        silenceTimer = null;
      }
      accumulatedTranscript = '';
      document.getElementById('transcript').textContent = '';

      updateMicButton();
    }

    async function previewVoice() {
      const btn = document.getElementById('voice-preview-btn');
      const originalText = btn.innerHTML;

      // Show loading state
      btn.innerHTML = '...';
      btn.disabled = true;

      try {
        const voice = document.getElementById('voice-select').value || 'brian';
        const text = 'The quick brown fox jumped over the lazy dog.';

        const response = await fetch(`${API_URL}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, voice, rate: '+0%' })
        });

        if (!response.ok) {
          throw new Error(`TTS failed: ${response.status}`);
        }

        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);

        audio.onended = () => {
          URL.revokeObjectURL(audioUrl);
          btn.innerHTML = originalText;
          btn.disabled = false;
        };

        audio.onerror = () => {
          URL.revokeObjectURL(audioUrl);
          btn.innerHTML = originalText;
          btn.disabled = false;
        };

        await audio.play();

      } catch (err) {
        console.error('Voice preview error:', err);
        btn.innerHTML = '!';
        setTimeout(() => {
          btn.innerHTML = originalText;
          btn.disabled = false;
        }, 2000);
      }
    }

    async function speak(text) {
      console.log('speak() called with:', text, 'voiceEnabled:', voiceEnabled);

      if (!voiceEnabled) {
        console.log('Voice disabled, skipping TTS');
        // Even if voice disabled, resume listening after a beat
        setTimeout(resumeListeningIfAlwaysOn, 500);
        return;
      }

      if (!text || text.trim() === '') {
        console.log('Empty text, skipping TTS');
        setTimeout(resumeListeningIfAlwaysOn, 500);
        return;
      }

      // Pause listening while speaking
      pauseListening();

      // Stop any current audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }

      try {
        // Update UI
        isSpeaking = true;
        updateMicButton();

        console.log('Fetching TTS for:', text.substring(0, 50) + '...');

        // Fetch audio from neural TTS endpoint
        const response = await fetch(`${API_URL}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: text,
            voice: selectedVoice,
            rate: '+0%'
          })
        });

        console.log('TTS response status:', response.status);

        if (!response.ok) {
          throw new Error(`TTS request failed: ${response.status}`);
        }

        const audioBlob = await response.blob();
        console.log('Audio blob size:', audioBlob.size);

        const audioUrl = URL.createObjectURL(audioBlob);
        currentAudio = new Audio(audioUrl);

        currentAudio.onended = () => {
          console.log('Audio playback ended');
          isSpeaking = false;
          URL.revokeObjectURL(audioUrl);
          currentAudio = null;
          updateMicButton();

          // Resume listening after TTS completes
          setTimeout(resumeListeningIfAlwaysOn, 300);
        };

        currentAudio.onerror = (e) => {
          console.error('Audio playback error:', e);
          isSpeaking = false;
          URL.revokeObjectURL(audioUrl);
          currentAudio = null;
          updateMicButton();

          // Resume listening even on error
          setTimeout(resumeListeningIfAlwaysOn, 300);
        };

        console.log('Playing audio...');
        await currentAudio.play();
        console.log('Audio play() started');

      } catch (err) {
        console.error('TTS error:', err);
        isSpeaking = false;
        updateMicButton();

        // Resume listening even on error
        setTimeout(resumeListeningIfAlwaysOn, 300);
      }
    }

    function resumeListeningIfAlwaysOn() {
      if (alwaysOnMode && !isSpeaking && !isThinking) {
        startListening();
      }
    }

    function stopSpeaking() {
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
      }
      isSpeaking = false;
      updateMicButton();

      // Resume listening if in always-on mode
      setTimeout(resumeListeningIfAlwaysOn, 100);
    }

    function skipSpeaking() {
      // Skip the current speech but don't stop permanently
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
        currentAudio = null;
      }
      isSpeaking = false;
      updateMicButton();

      // Resume listening immediately
      setTimeout(resumeListeningIfAlwaysOn, 100);
    }

    function toggleMic() {
      alwaysOnMode = !alwaysOnMode;
      const btn = document.getElementById('mic-toggle');

      if (alwaysOnMode) {
        btn.classList.add('active');
        btn.classList.remove('muted');
        btn.innerHTML = 'MIC';
        btn.title = 'Microphone (click to mute)';
        startListening();
      } else {
        btn.classList.remove('active');
        btn.classList.add('muted');
        btn.innerHTML = 'MIC';
        btn.title = 'Microphone muted (click to unmute)';
        pauseListening();
      }
    }

    function updateSpeakerButton() {
      const btn = document.getElementById('speaker-toggle');
      if (!btn) return;
      if (voiceEnabled) {
        btn.classList.add('active');
        btn.classList.remove('muted');
        btn.innerHTML = 'VOL';
        btn.title = 'Speaker (click to mute)';
      } else {
        btn.classList.remove('active');
        btn.classList.add('muted');
        btn.innerHTML = 'MUTE';
        btn.title = 'Speaker muted (click to unmute)';
      }
    }

    // ===========================================
    // Click-to-Move
    // ===========================================

    // These are declared at the top with other state variables
    // selectedSquare and legalMovesForSelected

    function setupClickToMove() {
      const boardEl = document.getElementById('board');

      // Simple approach: listen for clicks on the board container
      // chessboard.js handles drag, we handle click-to-move separately
      boardEl.addEventListener('click', function(e) {
        // Find the square that was clicked
        const squareEl = e.target.closest('[data-square]');
        if (!squareEl) {
          console.log('[CLICK] No square element found');
          return;
        }

        const square = squareEl.getAttribute('data-square');
        console.log('[CLICK EVENT] Square:', square);

        // Use setTimeout to let any drag operation complete first
        setTimeout(() => handleSquareClick(square), 0);
      });
    }

    function handleSquareClick(square) {
      console.log('[CLICK] handleSquareClick called with:', square);

      if (!gameState) {
        console.log('[CLICK] No gameState, returning');
        return;
      }
      if (gameState.is_game_over) {
        console.log('[CLICK] Game over, returning');
        return;
      }

      const position = board.position();
      const piece = position[square];
      const isPlayerTurn = gameState.turn === playerColor;

      // Check if we're in pre-move mode (AI is thinking or not our turn)
      const isPreMoveMode = isThinking || !isPlayerTurn;

      console.log('[CLICK] Processing:', square, 'selected:', selectedSquare, 'piece:', piece,
                  'isPreMoveMode:', isPreMoveMode, 'pendingPreMove:', preMovePendingSquare);

      // === PRE-MOVE MODE ===
      if (isPreMoveMode) {
        return handlePreMoveClick(square, piece, position);
      }

      // === NORMAL MOVE MODE ===
      // If we have a selected piece and clicked a different square
      if (selectedSquare && square !== selectedSquare) {
        console.log('[CLICK] Have selection, checking if', square, 'is legal target');
        console.log('[CLICK] Legal targets:', legalMovesForSelected);

        // Check if this is a legal move
        if (legalMovesForSelected.includes(square)) {
          // Make the move
          const uciMove = selectedSquare + square;
          console.log('[CLICK] SENDING MOVE:', uciMove);
          clearSelection();
          send({ type: 'move', move: uciMove });
          return;
        } else {
          console.log('[CLICK]', square, 'is NOT in legal targets');
        }

        // Check if clicking on another own piece - switch selection
        if (piece) {
          const isOwnPiece = (playerColor === 'white' && piece[0] === 'w') ||
                            (playerColor === 'black' && piece[0] === 'b');
          if (isOwnPiece) {
            selectSquare(square);
            return;
          }
        }

        // Clicked on invalid square - clear selection
        clearSelection();
        return;
      }

      // If clicked on own piece, select it
      if (piece) {
        const isOwnPiece = (playerColor === 'white' && piece[0] === 'w') ||
                          (playerColor === 'black' && piece[0] === 'b');
        if (isOwnPiece) {
          selectSquare(square);
          return;
        }
      }

      // Clicked elsewhere - clear selection
      clearSelection();
    }

    function handlePreMoveClick(square, piece, position) {
      console.log('[PREMOVE] Handling pre-move click:', square, 'pending:', preMovePendingSquare);

      // If we already have a pending pre-move square selected
      if (preMovePendingSquare) {
        // If clicking the same square, deselect
        if (square === preMovePendingSquare) {
          clearPreMoveSelection();
          return;
        }

        // Check if clicking on own piece - switch selection
        if (piece) {
          const isOwnPiece = (playerColor === 'white' && piece[0] === 'w') ||
                            (playerColor === 'black' && piece[0] === 'b');
          if (isOwnPiece) {
            selectPreMoveSquare(square);
            return;
          }
        }

        // Otherwise, queue this as a pre-move (from pending to clicked square)
        if (preMoveQueue.length < MAX_PREMOVES) {
          const preMove = { from: preMovePendingSquare, to: square };
          preMoveQueue.push(preMove);
          console.log('[PREMOVE] Queued pre-move:', preMove, 'Queue length:', preMoveQueue.length);

          clearPreMoveSelection();
          renderPreMoves();

          // Show feedback
          addMessage('system', `Pre-move queued: ${preMove.from} → ${preMove.to} (${preMoveQueue.length} in queue)`);
        } else {
          addMessage('system', `Max pre-moves reached (${MAX_PREMOVES}). Clear some first.`);
        }
        return;
      }

      // No pending selection - check if clicking on own piece to start pre-move
      if (piece) {
        const isOwnPiece = (playerColor === 'white' && piece[0] === 'w') ||
                          (playerColor === 'black' && piece[0] === 'b');
        if (isOwnPiece) {
          selectPreMoveSquare(square);
          return;
        }
      }

      // Clicked on empty square or opponent piece with no selection
      clearPreMoveSelection();
    }

    function selectPreMoveSquare(square) {
      console.log('[PREMOVE] Selecting square for pre-move:', square);
      clearPreMoveSelection();
      preMovePendingSquare = square;

      // Highlight the selected square
      $('[data-square="' + square + '"]').addClass('highlight-premove-pending');
    }

    function clearPreMoveSelection() {
      preMovePendingSquare = null;
      $('[data-square]').removeClass('highlight-premove-pending');
    }

    function renderPreMoves() {
      // Clear existing pre-move highlights
      $('[data-square]').removeClass('highlight-premove-from highlight-premove-to');
      $('.premove-badge').remove();

      // Highlight all queued pre-moves
      preMoveQueue.forEach((preMove, index) => {
        const fromEl = $('[data-square="' + preMove.from + '"]');
        const toEl = $('[data-square="' + preMove.to + '"]');

        fromEl.addClass('highlight-premove-from');
        toEl.addClass('highlight-premove-to');

        // Add badge with move number
        if (!fromEl.find('.premove-badge').length) {
          fromEl.css('position', 'relative').append(
            `<span class="premove-badge">${index + 1}</span>`
          );
        }
      });
    }

    function clearAllPreMoves() {
      preMoveQueue = [];
      clearPreMoveSelection();
      $('[data-square]').removeClass('highlight-premove-from highlight-premove-to highlight-premove-pending');
      $('.premove-badge').remove();
      console.log('[PREMOVE] Cleared all pre-moves');
    }

    async function executePreMoves() {
      console.log('[PREMOVE] Executing pre-moves. Queue:', preMoveQueue.length);

      while (preMoveQueue.length > 0 && gameState && !gameState.is_game_over) {
        const preMove = preMoveQueue[0];
        const uciMove = preMove.from + preMove.to;

        // Check if this pre-move is legal in current position
        if (gameState.legal_moves && gameState.legal_moves.some(m => m.startsWith(uciMove))) {
          console.log('[PREMOVE] Executing legal pre-move:', uciMove);
          preMoveQueue.shift();  // Remove from queue
          renderPreMoves();  // Update visuals

          // Send the move
          send({ type: 'move', move: uciMove });

          // Wait a bit for the server to process and AI to respond
          // The next pre-move will be executed after AI responds
          return;
        } else {
          // Pre-move is no longer legal - remove it and try next
          console.log('[PREMOVE] Pre-move no longer legal:', uciMove, 'removing');
          preMoveQueue.shift();
          addMessage('system', `Pre-move ${preMove.from} → ${preMove.to} was not legal, skipped`);
          renderPreMoves();
        }
      }

      // Clear any remaining visual state
      if (preMoveQueue.length === 0) {
        clearAllPreMoves();
      }
    }

    function selectSquare(square) {
      console.log('[SELECT] Selecting square:', square);
      clearSelection();
      selectedSquare = square;

      // Highlight selected square
      $('[data-square="' + square + '"]').addClass('highlight-selected');

      // Get legal moves for this piece from the game state
      if (gameState && gameState.legal_moves) {
        const matchingMoves = gameState.legal_moves.filter(m => m.startsWith(square));
        console.log('[SELECT] Matching UCI moves:', matchingMoves);

        legalMovesForSelected = matchingMoves.map(m => m.substring(2, 4));
        console.log('[SELECT] Legal target squares:', legalMovesForSelected);

        // Highlight legal moves
        legalMovesForSelected.forEach(target => {
          const targetEl = $('[data-square="' + target + '"]');
          const position = board.position();
          const hasPiece = position[target];
          if (hasPiece) {
            targetEl.addClass('highlight-capture');
          } else {
            targetEl.addClass('highlight-legal');
          }
        });
      }
    }

    function clearSelection() {
      selectedSquare = null;
      legalMovesForSelected = [];
      $('[data-square]').removeClass('highlight-selected highlight-legal highlight-capture highlight-last-move');
    }

    // Right-click to clear all pre-moves
    function setupPreMoveClearHandler() {
      const boardEl = document.getElementById('board');
      boardEl.addEventListener('contextmenu', function(e) {
        if (preMoveQueue.length > 0 || preMovePendingSquare) {
          e.preventDefault();
          clearAllPreMoves();
          addMessage('system', 'Pre-moves cleared');
        }
      });
    }

    // ===========================================
    // Replay Last AI Move
    // ===========================================

    function replayLastAIMove() {
      if (!lastAIMove || !board) return;

      // Clear previous highlights
      clearSelection();

      // Highlight the move squares
      $('.square-' + lastAIMove.from).addClass('highlight-last-move');
      $('.square-' + lastAIMove.to).addClass('highlight-last-move');

      // Optionally animate by briefly showing the piece moving
      // Flash effect
      setTimeout(() => {
        $('.square-' + lastAIMove.from).removeClass('highlight-last-move');
      }, 2000);

      setTimeout(() => {
        $('.square-' + lastAIMove.to).removeClass('highlight-last-move');
      }, 3000);
    }

    // ===========================================
    // Utilities
    // ===========================================

    function showError(msg) {
      const container = document.getElementById('error-container');
      container.innerHTML = `<div class="error-msg">${msg}</div>`;
    }

    // ===========================================
    // Game Over Modal
    // ===========================================

    function showGameOverModal(data) {
      pendingGameOver = data;

      // Set icon based on result
      const iconEl = document.getElementById('result-icon');
      if (data.result === 'win') {
        iconEl.textContent = 'VICTORY';
        iconEl.style.color = 'var(--accent-green)';
      } else if (data.result === 'loss') {
        iconEl.textContent = 'DEFEAT';
        iconEl.style.color = 'var(--accent-red)';
      } else {
        iconEl.textContent = 'DRAW';
        iconEl.style.color = 'var(--accent-yellow)';
      }

      // Set title and message
      const titleEl = document.getElementById('modal-title');
      if (data.result === 'win') {
        titleEl.textContent = 'Victory!';
      } else if (data.result === 'loss') {
        titleEl.textContent = 'Defeat';
      } else {
        titleEl.textContent = 'Draw';
      }

      document.getElementById('modal-message').textContent = data.message;
      document.getElementById('modal-moves').textContent = Math.ceil(data.moves_count / 2);
      document.getElementById('modal-color').textContent = data.player_color === 'white' ? 'White' : 'Black';
      document.getElementById('modal-difficulty').textContent = `Level ${currentDifficulty}`;

      // Clear name input
      document.getElementById('game-name-input').value = '';

      // Show modal
      document.getElementById('game-over-modal').classList.add('active');
    }

    function closeGameOverModal() {
      document.getElementById('game-over-modal').classList.remove('active');
      pendingGameOver = null;
    }

    async function saveGameResult() {
      if (!pendingGameOver) return;

      const gameName = document.getElementById('game-name-input').value.trim();

      try {
        const response = await fetch(`${API_URL}/api/game/default/record`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            result: pendingGameOver.result,
            name: gameName || null
          })
        });

        const data = await response.json();

        // Update difficulty display
        currentDifficulty = data.new_difficulty;
        document.getElementById('modal-difficulty').textContent = `${data.difficulty_name} (${data.new_difficulty})`;

        // Refresh stats
        document.getElementById('stat-games').textContent = data.stats.games_played;
        document.getElementById('stat-winrate').textContent = `${data.stats.win_rate}%`;
        document.getElementById('stat-record').textContent = `${data.stats.wins}/${data.stats.losses}/${data.stats.draws}`;

      } catch (err) {
        console.error('Failed to save game result:', err);
      }
    }

    // ===========================================
    // Analysis Modal with Replay
    // ===========================================

    async function showAnalysisModal() {
      const modal = document.getElementById('analysis-modal');
      modal.classList.add('active');

      // Show loading state
      document.getElementById('analysis-summary').textContent = 'Analyzing game...';
      document.getElementById('analysis-moves').innerHTML = '<div style="text-align:center;padding:20px;">Please wait...</div>';

      // Reset stats
      ['brilliant', 'great', 'best', 'inaccuracy', 'mistake', 'blunder'].forEach(type => {
        document.getElementById(`stat-${type}`).textContent = '0';
      });

      try {
        const response = await fetch(`${API_URL}/api/game/default/analysis`);
        const data = await response.json();

        if (data.error) {
          document.getElementById('analysis-summary').textContent = 'Analysis failed: ' + data.error;
          return;
        }

        // Store for replay
        analysisData = data;
        currentMoveIndex = -1;

        // Initialize analysis board
        if (!analysisBoard) {
          analysisBoard = Chessboard('analysis-board', {
            position: data.starting_fen || 'start',
            orientation: playerColor,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
          });
        } else {
          analysisBoard.position(data.starting_fen || 'start');
          analysisBoard.orientation(playerColor);
        }

        // Calculate stats for player's moves
        const playerMoves = data.moves.filter(m => m.color === playerColor);
        const stats = {
          brilliant: playerMoves.filter(m => m.classification === 'brilliant').length,
          great: playerMoves.filter(m => m.classification === 'great').length,
          best: playerMoves.filter(m => m.classification === 'best').length,
          good: playerMoves.filter(m => m.classification === 'good').length,
          inaccuracy: playerMoves.filter(m => m.classification === 'inaccuracy').length,
          mistake: playerMoves.filter(m => m.classification === 'mistake').length,
          blunder: playerMoves.filter(m => m.classification === 'blunder').length,
        };

        // Update stat cards
        document.getElementById('stat-brilliant').textContent = stats.brilliant;
        document.getElementById('stat-great').textContent = stats.great;
        document.getElementById('stat-best').textContent = stats.best + stats.good;
        document.getElementById('stat-inaccuracy').textContent = stats.inaccuracy;
        document.getElementById('stat-mistake').textContent = stats.mistake;
        document.getElementById('stat-blunder').textContent = stats.blunder;

        // Summary
        const totalErrors = stats.blunder + stats.mistake;
        const totalBrilliant = stats.brilliant + stats.great;
        if (totalBrilliant > 0 && totalErrors === 0) {
          document.getElementById('analysis-summary').textContent = `Excellent game! ${totalBrilliant} brilliant/great move${totalBrilliant > 1 ? 's' : ''}!`;
        } else if (totalErrors === 0) {
          document.getElementById('analysis-summary').textContent = 'Solid game! No major mistakes.';
        } else if (totalErrors <= 2) {
          document.getElementById('analysis-summary').textContent = 'Good game with only minor errors.';
        } else {
          document.getElementById('analysis-summary').textContent = `Review the ${totalErrors} significant errors below.`;
        }

        // Show ALL moves (not just errors)
        renderAnalysisMoves(data.moves);

        // Update move counter
        updateMoveCounter();
        updateReplayButtons();

      } catch (err) {
        console.error('Analysis error:', err);
        document.getElementById('analysis-summary').textContent = 'Failed to load analysis.';
      }
    }

    function renderAnalysisMoves(moves) {
      const movesContainer = document.getElementById('analysis-moves');
      movesContainer.innerHTML = '';

      moves.forEach((move, index) => {
        const div = document.createElement('div');
        div.className = `move-analysis ${move.classification}`;
        div.dataset.index = index;

        // Format move number (1. e4, 1... e5)
        const moveNotation = move.color === 'white'
          ? `${move.move_number}. ${move.move}`
          : `${move.move_number}... ${move.move}`;

        // Check/capture indicators
        let indicators = '';
        if (move.is_check) indicators += ' +';
        if (move.is_sacrifice) indicators += ' !';

        div.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <span><strong>${moveNotation}</strong>${indicators}</span>
            <span class="move-classification ${move.classification}">${move.classification}</span>
          </div>
          <div style="font-size:0.8rem;color:var(--text-secondary);margin-top:4px;">${move.comment}</div>
          ${move.best_move ? `<div class="move-eval">Best: ${move.best_move}</div>` : ''}
        `;

        // Click to jump to this move
        div.addEventListener('click', () => {
          replayGoTo(index);
        });

        movesContainer.appendChild(div);
      });
    }

    function replayGoTo(index) {
      if (!analysisData) return;

      // Clamp index
      index = Math.max(-1, Math.min(index, analysisData.moves.length - 1));
      currentMoveIndex = index;

      // Update board position
      if (index === -1) {
        analysisBoard.position(analysisData.starting_fen || 'start');
      } else {
        const move = analysisData.moves[index];
        analysisBoard.position(move.fen_after);
      }

      // Update move counter
      updateMoveCounter();

      // Update button states
      updateReplayButtons();

      // Highlight selected move in list
      document.querySelectorAll('.move-analysis').forEach((el, i) => {
        el.classList.toggle('selected', i === index);
      });

      // Scroll selected move into view
      const selectedEl = document.querySelector(`.move-analysis[data-index="${index}"]`);
      if (selectedEl) {
        selectedEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }

    function updateMoveCounter() {
      const counter = document.getElementById('move-counter');
      if (currentMoveIndex === -1) {
        counter.textContent = 'Starting position';
      } else {
        const move = analysisData.moves[currentMoveIndex];
        const moveNum = move.color === 'white'
          ? `Move ${move.move_number}. ${move.move}`
          : `Move ${move.move_number}... ${move.move}`;
        counter.textContent = moveNum;
      }
    }

    function updateReplayButtons() {
      const atStart = currentMoveIndex === -1;
      const atEnd = !analysisData || currentMoveIndex >= analysisData.moves.length - 1;

      document.getElementById('replay-first').disabled = atStart;
      document.getElementById('replay-prev').disabled = atStart;
      document.getElementById('replay-next').disabled = atEnd;
      document.getElementById('replay-last').disabled = atEnd;
    }

    function closeAnalysisModal() {
      document.getElementById('analysis-modal').classList.remove('active');
      analysisData = null;
      currentMoveIndex = -1;
    }

    // ===========================================
    // Load Saved Game Modal
    // ===========================================

    async function openLoadGameModal() {
      const modal = document.getElementById('load-game-modal');
      const listContainer = document.getElementById('saved-games-list');

      modal.classList.add('active');
      listContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Loading saved games...</div>';

      try {
        const response = await fetch(`${API_URL}/api/games/saved`);
        const data = await response.json();

        if (data.games && data.games.length > 0) {
          renderSavedGamesList(data.games);
        } else {
          listContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">No saved games found.</div>';
        }
      } catch (err) {
        console.error('Failed to load saved games:', err);
        listContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--accent-red);">Failed to load saved games.</div>';
      }
    }

    function renderSavedGamesList(games) {
      const listContainer = document.getElementById('saved-games-list');
      listContainer.innerHTML = '';

      games.forEach(game => {
        const div = document.createElement('div');
        div.style.cssText = 'padding: 12px; margin-bottom: 8px; background: var(--bg-primary); border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid var(--border-color);';

        // Format the date nicely
        const date = new Date(game.date);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

        // Determine result display
        let resultColor = 'var(--text-muted)';
        let resultText = game.result || 'In Progress';
        if (game.result === '1-0') {
          resultText = 'White wins';
          resultColor = game.player_color === 'white' ? 'var(--accent-green)' : 'var(--accent-red)';
        } else if (game.result === '0-1') {
          resultText = 'Black wins';
          resultColor = game.player_color === 'black' ? 'var(--accent-green)' : 'var(--accent-red)';
        } else if (game.result === '1/2-1/2') {
          resultText = 'Draw';
          resultColor = 'var(--accent-yellow)';
        } else if (!game.result) {
          resultText = 'In Progress';
          resultColor = 'var(--accent-blue)';
        }

        div.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <strong style="color: var(--text-primary);">${game.name || 'Unnamed Game'}</strong>
            <span style="color: ${resultColor}; font-size: 0.85rem; font-weight: 600;">${resultText}</span>
          </div>
          <div style="display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-muted);">
            <span>Playing as ${game.player_color || 'unknown'}</span>
            <span>${game.moves || 0} moves</span>
          </div>
          <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 4px;">
            ${dateStr} at ${timeStr}
          </div>
        `;

        div.addEventListener('mouseenter', () => {
          div.style.borderColor = 'var(--accent-blue)';
          div.style.transform = 'translateX(4px)';
        });
        div.addEventListener('mouseleave', () => {
          div.style.borderColor = 'var(--border-color)';
          div.style.transform = 'translateX(0)';
        });

        div.addEventListener('click', () => loadSavedGame(game.filename));
        listContainer.appendChild(div);
      });
    }

    async function loadSavedGame(filename) {
      closeLoadGameModal();

      try {
        const response = await fetch(`${API_URL}/api/games/load`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename })
        });

        const data = await response.json();

        if (data.error) {
          showError('Failed to load game: ' + data.error);
          return;
        }

        // Hide setup, show game screen
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('game-screen').classList.add('active');
        document.getElementById('new-game-btn').classList.remove('hidden');
        document.getElementById('messages').innerHTML = '';

        // Set player color from loaded game
        playerColor = data.player_color || 'white';

        // Initialize board
        const config = {
          draggable: true,
          position: data.state.fen,
          orientation: playerColor,
          onDragStart: onDragStart,
          onDrop: onDrop,
          onSnapEnd: onSnapEnd,
          pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        };

        board = Chessboard('board', config);
        $(window).resize(() => board.resize());

        // Add click-to-move and pre-move handlers
        setupClickToMove();
        setupPreMoveClearHandler();

        // Update game state
        gameState = data.state;
        updateGameInfo();
        updateMovesList();

        // Add system message
        addMessage('system', `Game loaded: ${data.game_name || filename}. ${data.state.half_moves} moves played. It's ${data.state.turn}'s turn.`);

        // Initialize button states
        updateMicButton();
        updateSpeakerButton();

        // Start listening if always-on
        setTimeout(() => {
          if (alwaysOnMode) {
            startListening();
          }
        }, 1000);

      } catch (err) {
        console.error('Failed to load game:', err);
        showError('Failed to load game. Please try again.');
      }
    }

    function closeLoadGameModal() {
      document.getElementById('load-game-modal').classList.remove('active');
    }

    // ===========================================
    // Training Mode Functions
    // ===========================================

    let trainingBoard = null;
    let trainingSession = null;
    let trainingOpening = null;
    let trainingSelectedSquare = null;
    let trainingLegalMoves = [];
    let trainingVoiceEnabled = true;

    async function loadOpenings() {
      try {
        const [openingsRes, statsRes] = await Promise.all([
          fetch(`${API_URL}/api/openings`),
          fetch(`${API_URL}/api/training/stats`)
        ]);
        const openingsData = await openingsRes.json();
        const statsData = await statsRes.json();

        // Update sessions today
        document.getElementById('training-sessions-today').textContent =
          `${statsData.sessions_today} / ${statsData.daily_goal}`;

        renderOpeningsList(openingsData.openings);
      } catch (err) {
        console.error('Failed to load openings:', err);
        document.getElementById('openings-list').innerHTML =
          '<div style="text-align: center; padding: 20px; color: var(--accent-red);">Failed to load openings</div>';
      }
    }

    function renderOpeningsList(openings) {
      const container = document.getElementById('openings-list');
      container.innerHTML = '';

      // Group by color
      const whiteOpenings = openings.filter(o => o.color === 'white');
      const blackOpenings = openings.filter(o => o.color === 'black');

      if (whiteOpenings.length > 0) {
        const header = document.createElement('div');
        header.className = 'opening-section-header';
        header.textContent = 'Play as White';
        container.appendChild(header);
        whiteOpenings.forEach(o => container.appendChild(createOpeningCard(o)));
      }

      if (blackOpenings.length > 0) {
        const header = document.createElement('div');
        header.className = 'opening-section-header';
        header.textContent = 'Play as Black';
        container.appendChild(header);
        blackOpenings.forEach(o => container.appendChild(createOpeningCard(o)));
      }
    }

    function createOpeningCard(opening) {
      const card = document.createElement('div');
      card.className = `opening-card ${opening.color}-opening`;
      card.innerHTML = `
        <div class="opening-name">${opening.name}</div>
        <div class="opening-desc">${opening.description}</div>
        <div class="opening-meta">
          <span>${opening.move_count} moves</span>
          <span>${opening.sessions_completed} sessions</span>
          <span class="mastery-badge ${opening.mastery_level}">${opening.mastery_level}</span>
          ${opening.response_to ? `<span>vs 1.${opening.response_to}</span>` : ''}
        </div>
      `;
      card.onclick = () => startTrainingSession(opening.id);
      return card;
    }

    async function startTrainingSession(openingId) {
      try {
        const response = await fetch(`${API_URL}/api/training/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ opening_id: openingId }),
        });
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.detail || 'Failed to start training');
        }

        trainingSession = data;

        // Hide modal and setup screen, show training screen
        document.getElementById('training-modal').classList.remove('active');
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('training-screen').classList.add('active');

        // Update UI first
        document.getElementById('training-opening-name').textContent = data.opening;
        updateTrainingHint(data.current_hint);
        updateTrainingProgress();

        // Initialize training board after DOM is ready (ChessboardJS needs visible container)
        requestAnimationFrame(() => {
          setTimeout(() => {
            initTrainingBoard(data);
          }, 50);
        });
        addTrainingMessage('info', `Let's practice the ${data.opening}. ${data.current_hint?.explanation || ''}`);

      } catch (err) {
        console.error('Failed to start training:', err);
        alert('Failed to start training: ' + err.message);
      }
    }

    function initTrainingBoard(sessionData) {
      const orientation = sessionData.player_color;

      // Destroy existing board if any
      if (trainingBoard) {
        trainingBoard.destroy();
      }

      trainingBoard = Chessboard('training-board', {
        position: sessionData.state.fen,
        orientation: orientation,
        draggable: true,
        onDragStart: onTrainingDragStart,
        onDrop: onTrainingDrop,
        onSnapEnd: onTrainingSnapEnd,
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
      });

      // Make board responsive
      $(window).on('resize', function() {
        if (trainingBoard) trainingBoard.resize();
      });

      // Setup click-to-move
      setupTrainingClickToMove();
    }

    function setupTrainingClickToMove() {
      const boardEl = document.getElementById('training-board');
      if (!boardEl) return;

      boardEl.addEventListener('click', function(e) {
        // ChessboardJS uses classes like 'square-e4', not data-square attributes
        const squareEl = e.target.closest('.square-55d63');
        if (!squareEl) return;

        // Extract square from class name (e.g., 'square-e4')
        const classes = squareEl.className.split(' ');
        const squareClass = classes.find(c => c.startsWith('square-') && c.length === 9);
        if (!squareClass) return;

        const square = squareClass.substring(7); // Remove 'square-' prefix
        setTimeout(() => handleTrainingSquareClick(square), 0);
      });
    }

    function handleTrainingSquareClick(square) {
      if (!trainingSession || !trainingBoard) return;

      const position = trainingBoard.position();
      const piece = position[square];

      // If we have a selected piece and clicked a different square
      if (trainingSelectedSquare && square !== trainingSelectedSquare) {
        // Check if this is a valid target
        if (trainingLegalMoves.includes(square)) {
          // Make the move
          const pieceAtSource = position[trainingSelectedSquare];
          const sanMove = buildTrainingSanMove(trainingSelectedSquare, square, pieceAtSource, position);
          clearTrainingSelection();
          submitTrainingMove(sanMove, trainingSelectedSquare, square);
          return;
        }
      }

      // Clicking on own piece - select it
      if (piece) {
        const isWhitePiece = piece.charAt(0) === 'w';
        const isOwnPiece = (trainingSession.player_color === 'white' && isWhitePiece) ||
                          (trainingSession.player_color === 'black' && !isWhitePiece);

        if (isOwnPiece) {
          selectTrainingSquare(square);
          return;
        }
      }

      // Clicked empty square or opponent piece without selection
      clearTrainingSelection();
    }

    function selectTrainingSquare(square) {
      clearTrainingSelection();
      trainingSelectedSquare = square;

      // Highlight selected square - ChessboardJS uses .square-{square} classes
      $('.square-' + square).addClass('highlight-selected');

      // Get legal moves from game state
      if (trainingSession && trainingSession.state && trainingSession.state.legal_moves) {
        const matchingMoves = trainingSession.state.legal_moves.filter(m => m.startsWith(square));
        trainingLegalMoves = matchingMoves.map(m => m.substring(2, 4));

        // Highlight legal moves
        const position = trainingBoard.position();
        trainingLegalMoves.forEach(target => {
          const targetEl = $('.square-' + target);
          if (position[target]) {
            targetEl.addClass('highlight-capture');
          } else {
            targetEl.addClass('highlight-legal');
          }
        });
      }
    }

    function clearTrainingSelection() {
      trainingSelectedSquare = null;
      trainingLegalMoves = [];
      $('#training-board .square-55d63').removeClass('highlight-selected highlight-legal highlight-capture');
    }

    function buildTrainingSanMove(from, to, piece, position) {
      const pieceType = piece ? piece.charAt(1).toUpperCase() : 'P';
      const isCapture = position[to] ? true : false;

      if (pieceType === 'P') {
        if (from.charAt(0) !== to.charAt(0)) {
          return from.charAt(0) + 'x' + to;
        }
        return to;
      } else if (pieceType === 'K') {
        // Check for castling
        if (from === 'e1' && to === 'g1') return 'O-O';
        if (from === 'e1' && to === 'c1') return 'O-O-O';
        if (from === 'e8' && to === 'g8') return 'O-O';
        if (from === 'e8' && to === 'c8') return 'O-O-O';
        return isCapture ? pieceType + 'x' + to : pieceType + to;
      } else {
        return isCapture ? pieceType + 'x' + to : pieceType + to;
      }
    }

    function onTrainingDragStart(source, piece, position, orientation) {
      // Don't allow moves if session is complete
      if (!trainingSession) return false;

      // Only allow moving your own pieces
      const isWhitePiece = piece.search(/^w/) !== -1;
      const isBlackPiece = piece.search(/^b/) !== -1;

      if (trainingSession.player_color === 'white' && isBlackPiece) return false;
      if (trainingSession.player_color === 'black' && isWhitePiece) return false;

      return true;
    }

    let trainingMoveInProgress = false;

    function onTrainingDrop(source, target, piece, newPos, oldPos, orientation) {
      // Ignore same-square drops (clicks)
      if (source === target) {
        return 'snapback';
      }

      // Prevent double submissions
      if (trainingMoveInProgress) {
        return 'snapback';
      }

      // Get piece type for SAN conversion
      const pieceType = piece.charAt(1).toUpperCase();
      let sanMove;

      if (pieceType === 'P') {
        sanMove = target; // Pawn moves are just the target square
        if (source.charAt(0) !== target.charAt(0)) {
          sanMove = source.charAt(0) + 'x' + target; // Capture
        }
      } else if (pieceType === 'K' && source === 'e1' && target === 'g1') {
        sanMove = 'O-O';
      } else if (pieceType === 'K' && source === 'e1' && target === 'c1') {
        sanMove = 'O-O-O';
      } else if (pieceType === 'K' && source === 'e8' && target === 'g8') {
        sanMove = 'O-O';
      } else if (pieceType === 'K' && source === 'e8' && target === 'c8') {
        sanMove = 'O-O-O';
      } else {
        sanMove = pieceType + target;
      }

      submitTrainingMove(sanMove, source, target);
      return 'snapback'; // Always snapback, we'll update after server response
    }

    function onTrainingSnapEnd() {
      // Update board position after snap
    }

    async function submitTrainingMove(move, source, target) {
      if (!trainingSession) return;
      if (trainingMoveInProgress) return;

      trainingMoveInProgress = true;

      try {
        const response = await fetch(`${API_URL}/api/training/${trainingSession.session_id}/move`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ move: move }),
        });
        const data = await response.json();

        if (data.correct) {
          // Update board position
          trainingBoard.position(data.state.fen);
          addTrainingMessage('correct', data.message);

          if (data.is_complete) {
            await completeTrainingSession();
          } else {
            // Update session state
            trainingSession.current_move_index = data.current_move_index;
            updateTrainingProgress();

            if (data.next_hint) {
              updateTrainingHint(data.next_hint);
            }

            // Show opponent's response if any
            if (data.opponent_move) {
              setTimeout(() => {
                addTrainingMessage('info', `Opponent plays ${data.opponent_move}`);
              }, 300);
            }
          }
        } else {
          // Wrong move - show feedback
          addTrainingMessage('incorrect', data.message);
          // Don't update board - let them try again
        }

        // Update accuracy display
        updateTrainingAccuracy();

      } catch (err) {
        console.error('Training move error:', err);
        addTrainingMessage('error', 'Error submitting move. Please try again.');
      } finally {
        trainingMoveInProgress = false;
      }
    }

    function updateTrainingHint(hint) {
      if (!hint) {
        document.getElementById('training-hint-move').textContent = 'Complete!';
        document.getElementById('training-hint-explanation').textContent = 'Opening sequence finished.';
        return;
      }

      const moveEl = document.getElementById('training-hint-move');
      const explEl = document.getElementById('training-hint-explanation');

      if (hint.level === 'full' && hint.move) {
        moveEl.textContent = hint.move;
      } else if (hint.level === 'partial' && hint.piece_hint) {
        moveEl.textContent = hint.piece_hint;
      } else if (hint.level === 'minimal') {
        moveEl.textContent = 'Your move...';
      } else {
        moveEl.textContent = '???';
      }

      explEl.textContent = hint.explanation || '';
    }

    function updateTrainingProgress() {
      if (!trainingSession) return;

      const current = trainingSession.current_move_index || 0;
      const total = trainingSession.total_moves || 8;
      const progress = (current / total) * 100;

      document.getElementById('training-progress-text').textContent = `Move ${current + 1} of ${total}`;
      document.getElementById('training-progress-value').textContent = `${Math.round(progress)}%`;
      document.getElementById('training-progress-bar').style.width = `${progress}%`;
    }

    function updateTrainingAccuracy() {
      if (!trainingSession) return;

      // Get state from server
      fetch(`${API_URL}/api/training/${trainingSession.session_id}/state`)
        .then(res => res.json())
        .then(data => {
          const session = data.session;
          const total = session.correct_moves + session.incorrect_moves;
          const accuracy = total > 0 ? (session.correct_moves / total) * 100 : 100;

          document.getElementById('training-accuracy-value').textContent = `${Math.round(accuracy)}%`;
          document.getElementById('training-accuracy-bar').style.width = `${accuracy}%`;
        })
        .catch(err => console.error('Failed to update accuracy:', err));
    }

    function addTrainingMessage(type, message, shouldSpeak = true) {
      const container = document.getElementById('training-messages');
      const msgEl = document.createElement('div');
      msgEl.className = 'message';

      if (type === 'correct') {
        msgEl.style.borderLeft = '3px solid var(--accent-green)';
        msgEl.style.background = 'rgba(34, 197, 94, 0.1)';
      } else if (type === 'incorrect') {
        msgEl.style.borderLeft = '3px solid var(--accent-red)';
        msgEl.style.background = 'rgba(239, 68, 68, 0.1)';
      } else if (type === 'error') {
        msgEl.style.borderLeft = '3px solid var(--accent-red)';
      } else {
        msgEl.style.borderLeft = '3px solid var(--accent-blue)';
      }

      msgEl.textContent = message;
      container.appendChild(msgEl);
      container.scrollTop = container.scrollHeight;

      // Speak the message if voice is enabled
      if (shouldSpeak && trainingVoiceEnabled && message) {
        speakTraining(message);
      }
    }

    let trainingCurrentAudio = null;

    async function speakTraining(text) {
      if (!trainingVoiceEnabled || !text) return;

      // Stop any currently playing audio
      if (trainingCurrentAudio) {
        trainingCurrentAudio.pause();
        trainingCurrentAudio = null;
      }

      try {
        // Use the same TTS endpoint as the main game
        const response = await fetch(`${API_URL}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: text }),
        });

        if (response.ok) {
          const audioBlob = await response.blob();
          const audioUrl = URL.createObjectURL(audioBlob);
          trainingCurrentAudio = new Audio(audioUrl);
          trainingCurrentAudio.play();
        }
      } catch (err) {
        console.error('Training TTS error:', err);
      }
    }

    // Voice input for training - uses Web Speech API
    let trainingRecognition = null;

    function startTrainingVoiceInput() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        addTrainingMessage('error', 'Voice input not supported in this browser', false);
        return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      trainingRecognition = new SpeechRecognition();
      trainingRecognition.continuous = false;
      trainingRecognition.interimResults = false;
      trainingRecognition.lang = 'en-US';

      const micBtn = document.getElementById('training-mic-btn');
      micBtn.classList.add('active');
      micBtn.textContent = '...';

      trainingRecognition.onresult = async (event) => {
        const transcript = event.results[0][0].transcript;
        addTrainingMessage('info', `You asked: "${transcript}"`, false);
        await handleTrainingQuestion(transcript);
      };

      trainingRecognition.onerror = (event) => {
        console.error('Training speech error:', event.error);
        micBtn.classList.remove('active');
        micBtn.textContent = 'MIC';
      };

      trainingRecognition.onend = () => {
        micBtn.classList.remove('active');
        micBtn.textContent = 'MIC';
      };

      trainingRecognition.start();
    }

    async function handleTrainingQuestion(question) {
      if (!trainingSession || !trainingOpening) return;

      try {
        // Use Ollama to answer questions about the current opening
        const context = `You are a chess coach helping a student learn the ${trainingOpening.name} opening.
The student is on move ${trainingSession.current_move_index + 1} of the opening.
Current hint: ${trainingSession.current_hint?.move || 'N/A'}
Opening description: ${trainingOpening.description}
Keep your answer brief and helpful.`;

        const response = await fetch(`${API_URL}/api/ask`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            question: question,
            context: context,
          }),
        });

        if (response.ok) {
          const data = await response.json();
          addTrainingMessage('info', data.answer);
        } else {
          addTrainingMessage('info', 'I can help you with questions about this opening. Try asking about why we play certain moves or what our plans are.');
        }
      } catch (err) {
        console.error('Training question error:', err);
        addTrainingMessage('info', 'I can help you with questions about this opening. Try asking about why we play certain moves or what our plans are.');
      }
    }

    // Voice input for review
    let reviewRecognition = null;

    function startReviewVoiceInput() {
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        addReviewFeedback(false, '', 'Voice input not supported in this browser');
        return;
      }

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      reviewRecognition = new SpeechRecognition();
      reviewRecognition.continuous = false;
      reviewRecognition.interimResults = false;
      reviewRecognition.lang = 'en-US';

      const micBtn = document.getElementById('review-mic-btn');
      if (micBtn) {
        micBtn.classList.add('active');
        micBtn.textContent = '...';
      }

      reviewRecognition.onresult = async (event) => {
        const transcript = event.results[0][0].transcript;
        // Try to parse the spoken move and submit it
        submitReviewAnswer(transcript);
      };

      reviewRecognition.onerror = (event) => {
        console.error('Review speech error:', event.error);
        if (micBtn) {
          micBtn.classList.remove('active');
          micBtn.textContent = 'MIC';
        }
      };

      reviewRecognition.onend = () => {
        if (micBtn) {
          micBtn.classList.remove('active');
          micBtn.textContent = 'MIC';
        }
      };

      reviewRecognition.start();
    }

    let reviewCurrentAudio = null;

    async function speakReview(text) {
      if (!reviewVoiceEnabled || !text) return;

      // Stop any currently playing audio
      if (reviewCurrentAudio) {
        reviewCurrentAudio.pause();
        reviewCurrentAudio = null;
      }

      try {
        const response = await fetch(`${API_URL}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: text }),
        });

        if (response.ok) {
          const audioBlob = await response.blob();
          const audioUrl = URL.createObjectURL(audioBlob);
          reviewCurrentAudio = new Audio(audioUrl);
          reviewCurrentAudio.play();
        }
      } catch (err) {
        console.error('Review TTS error:', err);
      }
    }

    async function completeTrainingSession() {
      if (!trainingSession) return;

      try {
        const response = await fetch(`${API_URL}/api/training/${trainingSession.session_id}/complete`, {
          method: 'POST',
        });
        const data = await response.json();

        const accuracy = Math.round(data.session_accuracy * 100);
        addTrainingMessage('info', `Training complete! Accuracy: ${accuracy}%`);
        addTrainingMessage('info', `New mastery level: ${data.new_mastery_level}`);
        addTrainingMessage('info', `Sessions today: ${data.sessions_today}/${data.daily_goal}`);

        // Show completion overlay or just wait a bit then go back
        setTimeout(() => {
          endTrainingSession();
        }, 3000);

      } catch (err) {
        console.error('Failed to complete training:', err);
      }
    }

    function endTrainingSession() {
      // Go back to setup screen
      document.getElementById('training-screen').classList.remove('active');
      document.getElementById('setup-screen').style.display = 'flex';

      // Clear training state
      trainingSession = null;
      if (trainingBoard) {
        trainingBoard.destroy();
        trainingBoard = null;
      }

      // Clear messages
      document.getElementById('training-messages').innerHTML = '';
    }

    // ===========================================
    // Review Mode Functions
    // ===========================================

    let reviewBoard = null;
    let reviewSession = null;
    let reviewSelectedSquare = null;
    let reviewLegalMoves = [];
    let reviewChessGame = null; // chess.js instance for computing legal moves
    let reviewVoiceEnabled = true;
    let reviewCurrentCard = null;

    async function loadReviewStats() {
      try {
        const response = await fetch(`${API_URL}/api/review/stats`);
        const stats = await response.json();

        document.getElementById('review-due-count').textContent = stats.due_count;
        document.getElementById('review-total-count').textContent = stats.total_cards;
        document.getElementById('review-mastered-count').textContent = stats.mastered_count;

        const startBtn = document.getElementById('start-review-btn');
        if (stats.due_count === 0) {
          startBtn.disabled = true;
          startBtn.textContent = 'No Cards Due';
        } else {
          startBtn.disabled = false;
          startBtn.textContent = `Start Review (${stats.due_count} cards)`;
        }

      } catch (err) {
        console.error('Failed to load review stats:', err);
      }
    }

    async function startReviewSession() {
      try {
        const response = await fetch(`${API_URL}/api/review/start`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ card_limit: 20 }),
        });
        const data = await response.json();

        if (!data.session_id) {
          alert(data.message || 'No cards to review');
          return;
        }

        reviewSession = data;

        // Hide modal and setup screen, show review screen
        document.getElementById('review-modal').classList.remove('active');
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('review-screen').classList.add('active');

        // Initialize review board after DOM is ready (ChessboardJS needs visible container)
        requestAnimationFrame(() => {
          setTimeout(() => {
            initReviewBoard(data.current_card);
            updateReviewUI(data.current_card);
          }, 50);
        });

      } catch (err) {
        console.error('Failed to start review:', err);
        alert('Failed to start review: ' + err.message);
      }
    }

    function initReviewBoard(card) {
      // Store current card for reference
      reviewCurrentCard = card;

      // Determine orientation from FEN (who's turn it is)
      const fenParts = card.fen.split(' ');
      const turn = fenParts[1] || 'w';
      const orientation = turn === 'w' ? 'white' : 'black';

      // Initialize chess.js for computing legal moves
      reviewChessGame = new Chess(card.fen);

      // Destroy existing board if any
      if (reviewBoard) {
        reviewBoard.destroy();
      }

      reviewBoard = Chessboard('review-board', {
        position: card.fen,
        orientation: orientation,
        draggable: true,
        onDragStart: onReviewDragStart,
        onDrop: onReviewDrop,
        pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
      });

      // Make board responsive
      $(window).on('resize', function() {
        if (reviewBoard) reviewBoard.resize();
      });

      // Setup click-to-move
      setupReviewClickToMove();
    }

    function setupReviewClickToMove() {
      const boardEl = document.getElementById('review-board');
      if (!boardEl) return;

      // Remove previous listener if any
      boardEl.removeEventListener('click', handleReviewBoardClick);
      boardEl.addEventListener('click', handleReviewBoardClick);
    }

    function handleReviewBoardClick(e) {
      // ChessboardJS uses classes like 'square-e4', not data-square attributes
      const squareEl = e.target.closest('.square-55d63');
      if (!squareEl) return;

      // Extract square from class name (e.g., 'square-e4')
      const classes = squareEl.className.split(' ');
      const squareClass = classes.find(c => c.startsWith('square-') && c.length === 9);
      if (!squareClass) return;

      const square = squareClass.substring(7); // Remove 'square-' prefix
      setTimeout(() => handleReviewSquareClick(square), 0);
    }

    function handleReviewSquareClick(square) {
      if (!reviewSession || !reviewBoard || !reviewChessGame) return;

      const position = reviewBoard.position();
      const piece = position[square];

      // If we have a selected piece and clicked a different square
      if (reviewSelectedSquare && square !== reviewSelectedSquare) {
        // Check if this is a valid target
        if (reviewLegalMoves.includes(square)) {
          // Make the move
          const pieceAtSource = position[reviewSelectedSquare];
          const sanMove = buildReviewSanMove(reviewSelectedSquare, square, pieceAtSource, position);
          clearReviewSelection();
          submitReviewAnswer(sanMove);
          return;
        }
      }

      // Clicking on a piece - select it if it's the side to move
      if (piece) {
        const isWhitePiece = piece.charAt(0) === 'w';
        const turnIsWhite = reviewChessGame.turn() === 'w';

        if ((turnIsWhite && isWhitePiece) || (!turnIsWhite && !isWhitePiece)) {
          selectReviewSquare(square);
          return;
        }
      }

      // Clicked empty square or wrong color piece without selection
      clearReviewSelection();
    }

    function selectReviewSquare(square) {
      clearReviewSelection();
      reviewSelectedSquare = square;

      // Highlight selected square - ChessboardJS uses .square-{square} classes
      $('.square-' + square).addClass('highlight-selected');

      // Get legal moves using chess.js
      const moves = reviewChessGame.moves({ square: square, verbose: true });
      reviewLegalMoves = moves.map(m => m.to);

      // Highlight legal moves
      const position = reviewBoard.position();
      reviewLegalMoves.forEach(target => {
        const targetEl = $('.square-' + target);
        if (position[target]) {
          targetEl.addClass('highlight-capture');
        } else {
          targetEl.addClass('highlight-legal');
        }
      });
    }

    function clearReviewSelection() {
      reviewSelectedSquare = null;
      reviewLegalMoves = [];
      $('#review-board .square-55d63').removeClass('highlight-selected highlight-legal highlight-capture');
    }

    function buildReviewSanMove(from, to, piece, position) {
      const pieceType = piece ? piece.charAt(1).toUpperCase() : 'P';
      const isCapture = position[to] ? true : false;

      if (pieceType === 'P') {
        if (from.charAt(0) !== to.charAt(0)) {
          return from.charAt(0) + 'x' + to;
        }
        return to;
      } else if (pieceType === 'K') {
        // Check for castling
        if (from === 'e1' && to === 'g1') return 'O-O';
        if (from === 'e1' && to === 'c1') return 'O-O-O';
        if (from === 'e8' && to === 'g8') return 'O-O';
        if (from === 'e8' && to === 'c8') return 'O-O-O';
        return isCapture ? pieceType + 'x' + to : pieceType + to;
      } else {
        return isCapture ? pieceType + 'x' + to : pieceType + to;
      }
    }

    function onReviewDragStart(source, piece, position, orientation) {
      if (!reviewSession) return false;
      return true;
    }

    function onReviewDrop(source, target, piece, newPos, oldPos, orientation) {
      // Build move in various formats to try matching
      const pieceType = piece.charAt(1).toUpperCase();
      let sanMove;

      if (pieceType === 'P') {
        sanMove = target;
        if (source.charAt(0) !== target.charAt(0)) {
          sanMove = source.charAt(0) + 'x' + target;
        }
      } else if (pieceType === 'K' && Math.abs(source.charCodeAt(0) - target.charCodeAt(0)) > 1) {
        sanMove = target.charAt(0) === 'g' ? 'O-O' : 'O-O-O';
      } else {
        sanMove = pieceType + target;
      }

      submitReviewAnswer(sanMove);
      return 'snapback';
    }

    async function submitReviewAnswer(move) {
      if (!reviewSession) return;

      try {
        const response = await fetch(`${API_URL}/api/review/${reviewSession.session_id}/answer`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ move: move }),
        });
        const data = await response.json();

        // Show feedback
        addReviewFeedback(data.correct, data.expected_move, data.explanation);

        // Update stats display
        document.getElementById('review-correct-count').textContent = data.session_stats.correct;
        document.getElementById('review-incorrect-count').textContent = data.session_stats.incorrect;

        // Update Leitner box indicator
        updateLeitnerBoxIndicator(data.new_box);

        if (data.is_session_complete) {
          setTimeout(() => completeReviewSession(), 2000);
        } else if (data.next_card) {
          // Load next card after a brief delay
          setTimeout(() => {
            reviewCurrentCard = data.next_card;
            reviewChessGame = new Chess(data.next_card.fen);
            clearReviewSelection();
            reviewBoard.position(data.next_card.fen);
            updateReviewUI(data.next_card);
            updateReviewProgress();
          }, 1500);
        }

      } catch (err) {
        console.error('Review answer error:', err);
      }
    }

    function updateReviewUI(card) {
      // Update card type badge
      const typeLabels = {
        'opening_sequence': 'Opening',
        'blunder_position': 'Blunder Review',
        'tactical_pattern': 'Tactics',
        'critical_position': 'Critical Position',
      };
      document.getElementById('review-card-type').textContent = typeLabels[card.card_type] || card.card_type;

      // Update opening hint if applicable
      const hintEl = document.getElementById('review-opening-hint');
      if (card.opening_id) {
        hintEl.textContent = `Opening: ${card.opening_id.replace(/_/g, ' ')}`;
        hintEl.style.display = 'block';
      } else {
        hintEl.style.display = 'none';
      }

      // Update Leitner box
      updateLeitnerBoxIndicator(card.box);
      document.getElementById('review-leitner-box').style.display = 'block';
    }

    function updateReviewProgress() {
      if (!reviewSession) return;
      const current = reviewSession.current_index || 0;
      const total = reviewSession.total_cards || 1;
      document.getElementById('review-progress-text').textContent = `Card ${current + 1} of ${total}`;

      // Update session object
      reviewSession.current_index = current + 1;
    }

    function updateLeitnerBoxIndicator(activeBox) {
      const boxes = document.querySelectorAll('.leitner-box');
      boxes.forEach(box => {
        const boxNum = parseInt(box.dataset.box);
        box.classList.remove('active', 'mastered');
        if (boxNum === activeBox) {
          box.classList.add(boxNum >= 5 ? 'mastered' : 'active');
        }
      });
    }

    function addReviewFeedback(correct, expectedMove, explanation) {
      const container = document.getElementById('review-feedback-area');
      const feedback = document.createElement('div');
      feedback.className = `review-feedback ${correct ? 'correct' : 'incorrect'}`;
      feedback.innerHTML = `
        <div class="feedback-title">${correct ? 'Correct!' : 'Incorrect'}</div>
        ${!correct ? `<div>Expected: <strong>${expectedMove}</strong></div>` : ''}
        <div class="feedback-explanation">${explanation || ''}</div>
      `;
      container.insertBefore(feedback, container.firstChild);

      // Keep only last 5 feedbacks
      while (container.children.length > 5) {
        container.removeChild(container.lastChild);
      }

      // Speak the feedback
      if (reviewVoiceEnabled) {
        let spokenText = correct ? 'Correct!' : `Incorrect. The expected move was ${expectedMove}.`;
        if (explanation) {
          spokenText += ' ' + explanation;
        }
        speakReview(spokenText);
      }
    }

    async function skipReviewCard() {
      if (!reviewSession) return;

      try {
        const response = await fetch(`${API_URL}/api/review/${reviewSession.session_id}/skip`, {
          method: 'POST',
        });
        const data = await response.json();

        if (data.is_session_complete) {
          completeReviewSession();
        } else if (data.next_card) {
          reviewCurrentCard = data.next_card;
          reviewChessGame = new Chess(data.next_card.fen);
          clearReviewSelection();
          reviewBoard.position(data.next_card.fen);
          updateReviewUI(data.next_card);
          updateReviewProgress();
        }
      } catch (err) {
        console.error('Failed to skip card:', err);
      }
    }

    async function completeReviewSession() {
      if (!reviewSession) return;

      try {
        const response = await fetch(`${API_URL}/api/review/${reviewSession.session_id}/complete`, {
          method: 'POST',
        });
        const data = await response.json();

        const accuracy = Math.round(data.accuracy * 100);
        alert(`Review complete!\n\nCorrect: ${data.correct_count}\nIncorrect: ${data.incorrect_count}\nAccuracy: ${accuracy}%`);

        endReviewSession();

      } catch (err) {
        console.error('Failed to complete review:', err);
        endReviewSession();
      }
    }

    function endReviewSession() {
      // Go back to setup screen
      document.getElementById('review-screen').classList.remove('active');
      document.getElementById('setup-screen').style.display = 'flex';

      // Clear review state
      reviewSession = null;
      if (reviewBoard) {
        reviewBoard.destroy();
        reviewBoard = null;
      }

      // Clear feedback
      document.getElementById('review-feedback-area').innerHTML = '';
    }

    // ===========================================
    // Training/Review Event Listeners Setup
    // ===========================================

    function setupTrainingReviewListeners() {
      // Training button
      document.getElementById('train-btn').addEventListener('click', () => {
        loadOpenings();
        document.getElementById('training-modal').classList.add('active');
      });

      document.getElementById('close-training-modal-btn').addEventListener('click', () => {
        document.getElementById('training-modal').classList.remove('active');
      });

      document.getElementById('end-training-btn').addEventListener('click', () => {
        if (confirm('End training session?')) {
          // Complete the session first if possible
          if (trainingSession) {
            fetch(`${API_URL}/api/training/${trainingSession.session_id}/complete`, { method: 'POST' })
              .catch(() => {});
          }
          endTrainingSession();
        }
      });

      // Review button
      document.getElementById('review-btn').addEventListener('click', () => {
        loadReviewStats();
        document.getElementById('review-modal').classList.add('active');
      });

      document.getElementById('close-review-modal-btn').addEventListener('click', () => {
        document.getElementById('review-modal').classList.remove('active');
      });

      document.getElementById('start-review-btn').addEventListener('click', startReviewSession);

      document.getElementById('skip-review-card-btn').addEventListener('click', skipReviewCard);

      document.getElementById('end-review-btn').addEventListener('click', () => {
        if (confirm('End review session?')) {
          completeReviewSession();
        }
      });

      // Close modals on outside click
      document.getElementById('training-modal').addEventListener('click', (e) => {
        if (e.target.id === 'training-modal') {
          document.getElementById('training-modal').classList.remove('active');
        }
      });

      document.getElementById('review-modal').addEventListener('click', (e) => {
        if (e.target.id === 'review-modal') {
          document.getElementById('review-modal').classList.remove('active');
        }
      });

      // Training voice controls
      const trainingSpeakerBtn = document.getElementById('training-speaker-toggle');
      if (trainingSpeakerBtn) {
        trainingSpeakerBtn.addEventListener('click', () => {
          trainingVoiceEnabled = !trainingVoiceEnabled;
          trainingSpeakerBtn.classList.toggle('muted', !trainingVoiceEnabled);
          trainingSpeakerBtn.classList.toggle('active', trainingVoiceEnabled);
          trainingSpeakerBtn.textContent = trainingVoiceEnabled ? 'VOL' : 'MUTE';
        });
      }

      const trainingMicBtn = document.getElementById('training-mic-btn');
      if (trainingMicBtn) {
        trainingMicBtn.addEventListener('click', () => {
          startTrainingVoiceInput();
        });
      }

      // Review voice controls
      const reviewSpeakerBtn = document.getElementById('review-speaker-toggle');
      if (reviewSpeakerBtn) {
        reviewSpeakerBtn.addEventListener('click', () => {
          reviewVoiceEnabled = !reviewVoiceEnabled;
          reviewSpeakerBtn.classList.toggle('muted', !reviewVoiceEnabled);
          reviewSpeakerBtn.classList.toggle('active', reviewVoiceEnabled);
          reviewSpeakerBtn.textContent = reviewVoiceEnabled ? 'VOL' : 'MUTE';
        });
      }

      const reviewMicBtn = document.getElementById('review-mic-btn');
      if (reviewMicBtn) {
        reviewMicBtn.addEventListener('click', () => {
          startReviewVoiceInput();
        });
      }
    }

    // Add to initialization
    document.addEventListener('DOMContentLoaded', () => {
      setupTrainingReviewListeners();
    });
  </script>
</body>
</html>
